%
% Filip Daca - Praca magisterska
% Warszawa, czerwiec 2015
%
% Formatownie dokumentu - Copyright (c) 2001 by Marcin Woliñski <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie - Seweryn Kar³owicz, 05.05.2006

\documentclass{pracamgr}

\usepackage{float}
\usepackage{graphicx}
\usepackage{polski}
\usepackage[cp1250]{inputenc}
\usepackage{hyperref}
\usepackage{enumitem}
 
\author{Filip Daca}
\nralbumu{305199}
\title{Metody wizualizacji kodu Ÿród³owego w repozytorium wspomagaj¹ce analizê jakoœci}
\tytulang{Repository source code visualization methods supporting quality analysis}
\kierunek{Informatyka}

\opiekun{dr Robert D¹browski\\
  Instytut Informatyki\\
  }

\date{Czerwiec 2015}

\dziedzina{ 
11.3 Informatyka\\ 
}

\klasyfikacja{Software and its engineering $\rightarrow$ Software creation and management\\
Human-centered computing $\rightarrow$ Visualization $\rightarrow$ Visualization systems and tools}

\keywords{wizualizacja kodu, wizualizacja konstelacyjna, mapa termiczna, analiza projektów informatycznych, eksploracja repozytorium, narzêdzia in¿ynierii oprogramowania}

\newtheorem{defi}{Definicja}[section]

\begin{document}
\maketitle

\begin{abstract}
Mo¿liwoœæ przejrzystej wizualizacji du¿ego projektu informatycznego jest kluczowa przy analizie jego dotychczasowego rozwoju. Dobra wizualizacja - pozwalaj¹ca na skuteczn¹ analizê, oprócz obrazowania elementów sk³adowych kodu Ÿród³owego oraz relacji miêdzy nimi, uwzglêdnia metryki u³atwiaj¹ce ocenê jakoœci i z³o¿onoœci badanych elementów kodu. Wzbogacenie wizualizacji o informacje pochodz¹ce z systemu kontroli wersji badanego projektu, pozwala na przeœledzenie przebiegu zmian w kodzie, a nawet na przewidywanie wyst¹pieñ usterek. W mojej pracy przeanalizowa³em trzy stosowane obecnie metody wizualizacji kodu, wypracowa³em wspólny dla nich model reprezentacji kodu, a uzyskane wyniki zaimplementowa³em w nowym narzêdziu do analizy i wizualizacji kodu. Wytworzone narzêdzie udostêpni³em publicznie na zasadach Open Source.
\end{abstract}

\tableofcontents

\begingroup
	\let\cleardoublepage\relax
	\listoffigures
	\listoftables
	\clearpage
\endgroup

% ------------------------------------------------------------------------------
% ROZDZIA£ WSTÊP
% ------------------------------------------------------------------------------
\chapter*{Wprowadzenie}
\addcontentsline{toc}{chapter}{Wprowadzenie}

In¿ynieria oprogramowania jest szerok¹ dziedzin¹, obejmuj¹c¹ ró¿norodne zagadnienia dotycz¹ce wytwarzania i zarz¹dzania oprogramowaniem. Analiza powstaj¹cego oprogramowania stanowi ga³¹Ÿ in¿ynierii, która ma du¿e znaczenie przy wytwarzaniu oprogramowania wysokiej jakoœci: niezawodnego, odpornego na usterki, rozszerzalnego. Jedn¹ z metod wspomagaj¹cych analizê oprogramowania jest wizualizacja - dziedzina zajmuj¹ca siê obrazowaniem oprogramowania. Istnieje wiele metod wizualizacji oprogramowania. Niektóre z metod szczególnie skutecznie wspomagaj¹ analizê jakoœci danego programu i umo¿liwiaj¹ przewidywanie przysz³ych zmian w projekcie na podstawie jego historii. W swojej pracy opisujê trzy tego typu metody wizualizacji, które zaimplementowa³em w narzêdziu open-source wspomagaj¹cym analizê oprogramowania, stanowi¹cym g³ówny wynik mojej pracy.

W rozdziale \ref{c:motivation} omawiam wybrane metody wizualizacji i przedstawiam swoj¹ motywacjê do stworzenia oprogramowania. Rozdzia³ \ref{c:model} opisuje przyjêty przeze mnie model oprogramowania, wspólny dla wybranych metod wizualizacji, pozwalaj¹cy na ich jednolit¹ implementacjê. W rozdziale \ref{c:software} przedstawiam architekrutê, budowê, dzia³anie i funkcjonalnoœæ stworzonego przeze mnie narzêdzia. Aby zweryfikowaæ wykorzystane w moim narzêdziu metody, pos³ugujê siê przyk³adami oraz badaniem, które opisujê w rozdziale \ref{c:research}. Podsumowanie i perspektywy dalszego rozwoju narzêdzia s¹ zebrane w rozdziale \ref{c:summary}.

% ------------------------------------------------------------------------------
% ROZDZIA£ MOTYWACJA
% ------------------------------------------------------------------------------
\chapter{Motywacja}\label{c:motivation}

Wizualizacja oprogramowania jest obszern¹ ga³êzi¹ in¿ynierii, która zajmuje siê koncepcjami, technikami, metodami i narzêdziami wspomagaj¹cymi pracê in¿ynierów oprogramowania przez wizualn¹ prezentacjê wybranych treœci i zagadnieñ. Najczêœciej wizualizowane s¹ projekty i systemy informatyczne, ich budowa, struktura, dzia³anie oraz ewolucja. Popularn¹ konferencj¹, która specjalizuje siê w metodach wizualizacji oprogramowania, jest organizowana przez IEEE (ang. \textit{Institute of Electrical and Electronics Engineers}) konferencja VISSOFT (ang. \textit{Visualizing Software for Understanding and Analysis} \cite{b:vissoft}. Wœród publikacji dotycz¹cych metod wizualizacji, zaprezentowanych na tej konferencji, skupi³em siê na pracach poruszaj¹cych nastêpuj¹ce problemy:

\begin{enumerate}[label=(\alph*)]
\item Opis metody obrazowania kodu projektu - w jaki sposób wizualizowane jest oprogramowanie? 
\item Mo¿liwoœæ wizualizacji jakoœci kodu - czy opisywana metoda pozwala na obrazowania miar jakoœci? 
\item Uwzglêdnienie analizy historycznej kodu - czy wizualizacja uwzglêdnia i obrazuje zmiany w projekcie?
\end{enumerate}

¯adna z rozpatrywanych publikacji nie pokrywa³a siê w pe³ni z wszystkimi trzema zagadnieniami, ale kilka prac w ciekawy sposób porusza³o czêœæ z nich. W tym rozdziale podsumujê trzy wybrane artyku³y, które w interesuj¹cy sposób uwzglêdniaj¹ czêœæ z wy¿ej wymienionych aspektów, a pomys³y z tych prac zebrane w jedn¹ ca³oœæ sk³adaj¹ siê na przydatne narzêdzie.

\section{Wizualizacja grafowa}\label{s:motivation-graph}

W swojej pracy U. Erdemir, U. Tekin i F. Buzluca \cite{b:graph} proponuj¹ standardow¹ metodê wizualizacji kodu w postaci grafu [rysunek \ref{i:motivation-graph}]. Autorzy skupiaj¹ siê na paradygmacie obiektowym i wizualizacji projektu na poziomie klas. Stworzone przez nich narzêdzie wydobywa metryki jakoœciowe z kodu Ÿród³owego analizowanego oprogramowania i przedstawia je w opartym na grafie interaktywnym œrodowisku. Proponowane podejœcie pomaga twórcom oprogramowania oceniæ jakoœæ kodu przez zastosowanie kategoryzacji atrybutów jakoœciowych i intuicyjne techniki wizualizacji.

\subsection{Wykorzystane techniki}

Autorzy w swoim narzêdziu wizualizuj¹ kod w postaci grafu, w którym wierzcho³ki reprezentuj¹ klasy, a krawêdzie oznaczaj¹ zale¿noœci miêdzy klasami, np.: dziedziczenie, implementacjê, widocznoœæ. Aby uskuteczniæ analizê jakoœci oprogramowania, autorzy klasyfikuj¹ wartoœci wybranych metryk na kategorie: \textit{niska}, \textit{umiarkowanie niska}, \textit{umiarkowanie wysoka} i \textit{wysoka}. Nastêpnie wizualizuj¹ te informacje za pomoc¹ nastêpuj¹cych technik:

\begin{itemize}
\item{Rozmiar wierzcho³ków} - zmieniaj¹c rozmiar wierzcho³ka obrazowany jest faktyczny rozmiar reprezentowanej klasy - niewielkie wierzcho³ki oznaczaj¹ klasy z niewielk¹ liczb¹ metod, pól i instrukcji.
\item{Kolor wierzcho³ków} - przez manipulacjê kolorem wierzcho³ka, autorzy oddaj¹ z³o¿onoœæ danej klasy. Wierzcho³ki czerwone to klasy o du¿ej z³o¿onoœci, a wierzcho³ki niebieskie to klasy nieskomplikowane.
\item{Kszta³t wierzcho³ków} - modyfikuj¹c kszta³t wierzcho³ka oznaczany jest stopieñ zwi¹zania danej klasy. Wierzcho³ki w kszta³cie gwiazdy s¹ silnie zwi¹zane z innymi klasami, a wierzcho³ki o kszta³tach ³agodniejszych symbolizuj¹ klasy samodzielnie, lub o niskim powi¹zaniu.
\item{Kolor krawêdzi} - kolor krawêdzi w grafie oznacza rodzaj powi¹zania symbolizowanego przez dan¹ krawêdŸ. Przyk³adowo, kolor zielony oznacza implementacjê, a b³êkitny widocznoœæ.
\item{Gruboœæ krawêdzi} - przez modyfikacjê gruboœci krawêdzi autorzy oznaczaj¹ si³ê zale¿noœci reprezentowan¹ przez dan¹ krawêdŸ. Przyk³adowo, jeœli krawêdŸ oznacza wywo³ywanie metod z jednej klasy przez drug¹, gruboœæ krawêdzi bêdzie odwzorowywaæ liczbê takich wywo³añ. 
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{bib3.png}
\caption{Projekt PDE wizualizowany w postaci grafu podany jako przyk³ad autorów pracy \cite{b:graph}}
\label{i:motivation-graph}
\end{figure}

\subsection{Podsumowanie grafu}

Metoda zaproponowana przez autorów jest prosta w interpretacji i zrozumia³a dla u¿ytkownika. Za pomoc¹ grafu mo¿na w ³atwy sposób wizualizowaæ poszczególne cechy projektu nanosz¹c kolory na wybrane wierzcho³ki / krawêdzie. Autorzy potwierdzili eksperymentalnie, ¿e zastosowana przez nich metoda mo¿e byæ u¿yta do detekcji niedoskona³oœci projektowych i fragmentów kwalifikuj¹cych siê do refaktoryzacji. Opisana praca porusza wspomniane przeze mnie problemy (a) oraz (b).

\section{Wizualizacja konstelacyjna}\label{s:motivation-constellation}

Ciekaw¹ metod¹ zaproponowan¹ przez F. Deng, N. DiGgiuseppe i J. A. Jones \cite{b:constellation} jest konstelacja [rysunek \ref{i:motivation-constellation}]. Ten sposób wizualizacji zosta³ opracowany w celu ³atwego wyodrêbniania fragmentów kodu o wybranych w³aœciwoœciach (przyk³adowo klas zawieraj¹cych potencjalne usterki) oraz wizualnej separacji elementów nieinteresuj¹cych od istotnych (przyk³adowo klas wadliwych od prawid³owych). Wizualizacja konstelacyjna wygl¹dem przypomina gwieŸdziste niebo, na którym gwiazdy reprezentuj¹ poszczególne elementy kodu, a zale¿noœci miêdzy nimi s¹ obrazowane przez manipulacjê odleg³oœci¹. 

\subsection{Zasada budowy wizualizacji konstelacyjnej}

Wizualizacja konstelacyjna opiera siê w du¿ej mierze na modyfikacji wizualizacji grafowej i wzbogaceniu jej o dodatkowe efekty. W swojej pracy autorzy opisuj¹ kroki potrzebne do przetworzenia grafu zale¿noœci (o dowolnej granularnoœci) w konstelacjê. S¹ to kolejno:

\paragraph{Ukrycie krawêdzi:}
Dla lepszej skalowalnoœci uk³adu i interpretacji u¿ytkownika, w grafie zale¿noœci projektu nale¿y zrezygnowaæ z wizualizacji krawêdzi.

\paragraph{Uproszczenie wierzcho³ków:}
Dla lepszej rozszerzalnoœæ interpretacyjnej, wierzcho³ki powinny byæ wizualizowane jako pojedynczy punkt.

\paragraph{Kolorowanie wierzcho³ków na podstawie meta-danych:}
Dla obrazowania konkretnego problemu, wierzcho³ki powinny zostaæ pokolorowane wed³ug wybranych meta-danych. Przyk³adowo, jeœli interesuje nas jakoœæ wizualizowanego kodu, mo¿emy pos³ugiwaæ siê informacj¹ o jakoœci / liczbie usterek danego wierzcho³ka. Autorzy w swoich przyk³adach u¿yli informacji o podejrzanych instrukcjach pochodz¹cych z narzêdzia Tarantula rozwijanego w ramach prac nad detekcj¹ usterek \cite{b:tarantulla}

\paragraph{Nadanie si³ krawêdziom:}
Dla u³atwienia interpretacji i lepszego powi¹zania kontekstowego wizualizowanych wierzcho³ków, krawêdzie powinny swoj¹ d³ugoœci¹ reprezentowaæ si³ê powi¹zania. Autorzy zastosowali w swoich przyk³adach informacje pozyskane przy dynamicznej analizie projektu. Podczas dynamicznej analizy program by³ uruchamiany dla wybranych przypadków testowych. Ka¿da z krawêdzi grafu otrzyma³a swoj¹ si³ê w zale¿noœci od tego, jak czêsto dana zale¿noœæ by³a realizowana podczas uruchomieñ testowych. W wyniku tego krawêdzie o niewielkiej sile oznaczaj¹ zale¿noœci wystêpuj¹ce bardzo rzadko podczas dzia³ania programu.

\paragraph{Równowa¿enie / klastrowanie:}
Aby metoda pozwala³a jeszcze dok³adniej interpretowaæ wizualizacjê pod k¹tem konkretnego problemu, konstelacja mo¿e zrównowa¿yæ po³o¿enie wierzcho³ków. Zamys³em autorów by³o wizualne rozdzielenie grup wierzcho³ków o wspólnych cechach. W swoim przyk³adzie autorzy wprowadzili kategoryzowanie uruchomieñ, aby wzbogaciæ informacje z dynamicznej analizy.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{bib1.png}
\caption{Projekt Gzip wizualizowany w postaci konstelacji podany jako przyk³ad autorów pracy \cite{b:constellation}}
\label{i:motivation-constellation}
\end{figure}

\subsection{Badania potwierdzaj¹ce skutecznoœæ konstelacji}

Autorzy pracy przeprowadzili badania, które potwierdzi³y skutecznoœæ metody konstelacyjnej w czytelnej wizualizacji kodu z uwzglêdnieniem potencjalnych usterek. W teœcie wziê³o udzia³ 30 studentów informatyki uniwersytetu w Kalifornii, o ró¿nym stopniu doœwiadczenia. Do testu przygotowano 4 projekty informatyczne, w których kodzie umieszczono co najmniej 20 losowych usterek. Nastêpnie na podstawie wizualizacji konstelacyjnej oraz mapy kodu\footnote{Mapa kodu jest metod¹ wizualizacji, która ukazuje kod programu w swojej bezpoœredniej postaci tekstowej, ale w bardzo du¿ym pomniejszeniu - tak aby wszystkie linie kodu z wizualizowanego pliku b¹dŸ klasy zmieœci³y siê w obszarze wizualizacji. Teks wizualizowany w ten sposób jest zbyt ma³y aby go rozczytaæ, ale ze wzglêdu na charakterystyczne formatowanie, wciêcia i bia³e znaki, u¿ytkownik jest w stanie rozpoznaæ widoczny fragmenty kodu i zlokalizowaæ go w pliku Ÿród³owym.} uczestnicy badania mieli wskazaæ przypuszczaln¹ lokalizacjê usterki przez oznaczenie odpowiednich elementów kodu. Obie wizualizacje by³y oznaczone kolorami na podstawie meta-danych dostarczonych przez narzêdzie analizuj¹ce jakoœæ kodu i obrazowa³y kod na poziomie instrukcji. Dziêki temu autorzy byli w stanie w mierzalny sposób stwierdziæ, jaka objêtoœæ kodu jest podejrzana wed³ug uczestników badania. W wyniku testu autorzy wykazali, ¿e w ka¿dym przypadku wizualizacja konstelacyjna wymaga³a od u¿ytkowników przejrzenia znacznie mniejszej liczby linii kodu, ni¿ w przypadku wizualizacji metod¹ mapy kodu Seesoft \cite{b:see-soft}.

\subsection{Podsumowanie konstelacji}

Wizualizacja konstelacyjna jest metod¹, która dobrze nadaje siê do wielu zastosowañ in¿ynierii oprogramowania i mo¿na j¹ przeprowadziæ uzupe³niaj¹c graf wizualizowanego projektu o odpowiednie metadane. Skutecznoœæ metody potwierdzono badaniami, w których wykazano, ¿e programiœci potrzebuj¹ mniej czasu na identyfikacjê usterek w kodzie, kiedy pos³uguj¹ siê konstelacj¹, w porównaniu do mapy dokumentu. Opisana praca porusza wspomniane przeze mnie problemy (a) oraz (b).

\section{Mapa termiczna}\label{s:motivation-heatmap}

Praca autorstwa O. Benomar, H. Sahraoui, P. Poulin \cite{b:heatmaps} przedstawia kilka interesuj¹cych zastosowañ mapy termicznej w wizualizacji projektów. W swojej pracy autorzy opisuj¹ metodê wizualizacji kodu w postaci miast i budynków, a wykorzystana w tle mapa termiczna s³u¿y do oznaczania dynamiki projektu.

\subsection{Zastosowania}

Mapy termiczne s¹ dwuwymiarowymi obiektami wykorzystuj¹cymi metaforê ciep³a do reprezentowania intensywnoœci lub wa¿noœci wybranej cechy. W zale¿noœci od rozk³adu wybranej cechy, kolory mapy termicznej interpoluj¹ ze sob¹ tworz¹c wyraŸnie obserwowalne otoczenia o wiêkszym zagêszczeniu danej w³aœciwoœci. Taki charakter map termicznych mo¿e mieæ zastosowanie w wizualizacji zmian zachodz¹cych w projekcie. Autorzy rozwa¿aj¹ przyk³ady oparte na historycznych w³aœciwoœciach kodu:

\paragraph{Czas zmian:} Zastosowanie mapy termicznej do obrazowania wieku ostatniej zmiany danego fragmentu kodu. Autorzy wizualizuj¹c projekt w postaci miast, klasy programu przedstawiali w formie budynków. Budynki na tle o wysokiej temperaturze oznacza³y klasy, które by³y niedawno modyfikowane. Taka wizualizacja umo¿liwia analizê zagadnieñ: 

\begin{itemize}
\item Nad jak¹ czêœci¹ projektu trwaj¹ aktualnie prace? 
\item Które elementy projektu nie by³y od dawna zmieniane?
\end{itemize}

\paragraph{Liczba zmian:} U¿ycie mapy termicznej do oznaczenia ca³kowitej liczby zmian danego fragmentu kodu. Autorzy wysok¹ temperatur¹ oznaczaj¹ klasy czêsto modyfikowane. Takie podejœcie pozwala znaleŸæ odpowiedzi na pytania:

\begin{itemize}
\item Która klasa / fragment oprogramowania jest kluczowym, stale rozwijanym elementem projektu?
\item Które elementy projektu ulegaj¹ czêstym zmianom, a które pozostaj¹ niezmodyfikowane?
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{bib2.png}
\caption{Projekt JHotDraw wizualizowany w postaci miasta przy u¿yciu mapy termicznej w przyk³adzie z pracy \cite{b:heatmaps}}
\end{figure}

\subsection{Podsumowanie map termicznych}

Mapa termiczna mo¿e byæ dodatkowym elementem wizualizacji, który w dobry sposób oddaje dynamikê projektu. Rozmyty charakter obrazowania termicznego, szczególnie wykorzystany w tle konkretnej wizualizacji, rozszerza otoczenie pojedynczych elementów i przyczynia siê do powstawania obszarów o konkretnych w³aœciwoœciach. Przyk³adowo - obszary o wiêkszej temperaturze mog¹ obrazowaæ skupiska kodu czêsto modyfikowanego. Opisana praca porusza wspomniane przeze mnie aspekty (a) oraz (c).

% ------------------------------------------------------------------------------
% ROZDZIA£ MODEL
% ------------------------------------------------------------------------------
\chapter{Model}\label{c:model}

Aby przygotowaæ wizualizacjê, która jednolicie zobrazuje kod projektu informatycznego, uwzglêdniaj¹c miêdzy innymi jego jakoœæ i dane historyczne nale¿y ustaliæ odpowiedni model reprezentacji programu komputerowego. W tym rozdziale przedstawiê model, który przyj¹³em do reprezentacji oprogramowania w swoim narzêdziu.

\section{Oprogramowanie jako graf}\label{s:model-graph}

W swojej pracy ograniczy³em siê do analizy kodu na poziomie pakietów. Przyjêty przeze mnie model analizowanego projektu ma strukturê skierowanego grafu, w którym wierzcho³ki reprezentuj¹ pakiety programu, a krawêdzie zale¿noœci miêdzy nimi. Przyjêty model ilustruje rysunek \ref{i:model} oraz \ref{i:model-more}

\subsection{Wierzcho³ki}

Ka¿dy wierzcho³ek grafu posiada swój typ i nazwê pakietu, który reprezentuje. W zale¿noœci od typu, wierzcho³ek mo¿e posiadaæ te¿ inne atrybuty. W modelu wyró¿niamy nastêpuj¹ce typy wierzcho³ków:

\begin{itemize}
\item \textbf{Wierzcho³ki pakietowe} - reprezentuj¹ pakiety analizowanego projektu.
	\begin{itemize}
	\item \textbf{Wierzcho³ki pakietów analizowanych} - s¹ to pakiety, dla których chcielibyœmy przeprowadziæ analizê jakoœci i wydobyæ dane historyczne. W rzeczywistoœci ten rodzaj wierzcho³ków reprezentuje fragmenty kodu stworzone w procesie realizacji danego projektu.
	\item \textbf{Wierzcho³ki pakietów bibliotecznych} - s¹ to pakiety, które wchodz¹ w sk³ad projektu ale nie podlegaj¹ szczegó³owej analizie jakoœciowej i historycznej. Wierzcho³ki te mog¹ reprezentowaæ biblioteki zewnêtrzne, które zosta³y za³¹czone do analizowanego projektu, bez ingerencji w ich kod. Przyk³adem mo¿e byæ pakiet \texttt{java.lang}, który jest u¿ywany w projekcie, ale definicja jego klas nie znajduje siê w kodzie Ÿród³owym projektu.
	\end{itemize}
\item \textbf{Wierzcho³ki katalogowe} - s¹ to pakiety, które nie posiadaj¹ swoich klas, ale zawieraj¹ inne pakiety. Wierzcho³ki te mog¹ byæ rozumiane jako katalogi w drzewie katalogów projektu, gdy¿ reprezentuj¹ kolejne elementy œcie¿ki danego pakietu. Przyk³adowymi wierzcho³kami katalogowymi bêd¹ \texttt{org} oraz \texttt{org.apache}, jeœli w projekcie znajduje siê pakiet \texttt{org.apache.commons.io}.
\end{itemize}

\subsection{Krawêdzie}

Ka¿da krawêdŸ grafu posiada swój typ oraz jest w stanie okreœliæ ³¹czone wierzcho³ki i si³ê powi¹zania miêdzy nimi. W moim modelu wyró¿niam dwa rodzaje krawêdzi:

\begin{itemize}
\item \textbf{Krawêdzie drzewa pakietów} - odzwierciedlaj¹ strukturê fizyczn¹ programu. Tego typu krawêdziami po³¹czone s¹ wierzcho³ki bêd¹ce w relacji “ojciec - syn” w drzewie pakietów. Przyk³adowo, pakiet \texttt{shimmer.service.impl} znajduje siê wewn¹trz pakietu \texttt{shimmer.service}, wiêc ich wierzcho³ki bêd¹ po³¹czone tak¹ krawêdzi¹. Równie¿ w tym przypadku sztuczny wierzcho³ek katalogowy \texttt{shimmer} po³¹czony bêdzie z wierzcho³kiem pakietowym \texttt{shimmer.service}. Si³a powi¹zania dla takich krawêdzi jest sta³a.
\item \textbf{Krawêdzie zale¿noœci miêdzy pakietami} - odzwierciedlaj¹ logiczne powi¹zania ³¹cz¹ce pakiety. Tego typu krawêdziami powi¹zane s¹ pakiety, których klasy korzystaj¹ z siebie nawzajem. Przyk³adowo, jeœli jakaœ klasa pakietu \texttt{shimmer.service} polega na innej klasie z pakietu \texttt{shimmer.service.impl}, pakiety po³¹czone bêd¹ tak¹ krawêdzi¹. Si³a takiego powi¹zania odpowiada liczbie zale¿nych klas - krawêdzie tego typu posiadaæ bêd¹ ró¿ne wartoœci si³y powi¹zania.
\end{itemize}

\begin{figure}[t]
\centering
\includegraphics[width=0.6\textwidth]{model1.png}
\caption{Fragment grafu projektu Hibernate - na przyk³adzie widoczne s¹ krawêdzie drzewa pakietów, zielone wierzcho³ki pakietowe, szare wierzcho³ki biblioteczne oraz niebieskie wierzcho³ki katalogowe. Dla zwiêkszenia czytelnoœci krawêdzie zale¿noœci pomiêdzy pakietami zosta³y ukryte. Szczegó³owe zbli¿enie przedstawiono na rysunku \ref{i:model-more}}
\label{i:model}
\end{figure}

\begin{figure}[t]
\centering
\includegraphics[width=0.6\textwidth]{model2.png}
\caption{Zbli¿enie fragmentu grafu z rysunku \ref{i:model}. Na zbli¿eniu widaæ etykiety pakietów reprezentowanych przez poszczególne wierzcho³ki.}
\label{i:model-more}
\end{figure}

\section{Potencjalne usterki}\label{s:model-bugs}

Chc¹c uwzglêdniæ w wizualizacji podejrzane fragmenty oprogramowania, wprowadzi³em do modelu pojêcie \textit{potencjalnej usterki}. Obiekty te wyra¿aj¹ wykryte zagro¿enie, które mo¿e prowadziæ do powstawania b³êdów w przysz³oœci. Wykryta usterka dotyczyæ mo¿e dowolnego fragmentu kodu - w przyjêtym modelu ka¿dy \textit{wierzcho³ek pakietu analizowanego} bêdzie grupowa³ potencjalne usterki wykryte w obrêbie danego pakietu.

Ka¿da potencjalna usterka posiada szereg atrybutów charakteryzuj¹cych zagro¿enie:

\begin{itemize}
\item \textbf{Lokalizacja b³êdu} - pozwala ustaliæ, w jakim fragmencie kodu wystêpuje dana potencjalna usterka. Ta informacja powinna nie tylko jednoznacznie wskazywaæ pakiet, w którym wykryto potencjaln¹ usterkê, ale równie¿ pozwalaæ na dok³adniejsze zlokalizowanie problemu w kodzie programu.
\item \textbf{Typ b³êdu} - okreœla na czym polega wykryta potencjalna usterka. Na podstawie tej informacji jesteœmy w stanie wyszukaæ rozwi¹zania dla wykrytego potencjalnego problemu.
\item \textbf{Priorytet b³êdu} - kategoryzuje potencjalne usterki ze wzglêdu na ich wa¿noœæ.
\item \textbf{Pewnoœæ} - zaproponowane pojêcie potencjalnej usterki ma symbolizowaæ fragment podejrzany, dlatego istotn¹ informacj¹ jest miara przekonania o wyst¹pieniu danego problemu. 
\end{itemize}


\section{Metryki jakoœciowe}\label{s:model-metrics}

Aby móc analizowaæ projekt pod k¹tem jakoœciowym, rozwa¿am szereg metryk oddaj¹cych charakter badanego kodu. W swojej pracy ograniczam siê do wybranych metryk projektowych na poziomie pakietowym \cite{b:metrics}. Wartoœci poszczególnych metryk w tym przypadku dotycz¹ pakietów, a w opisywanym modelu s¹ atrybutami \textit{wierzcho³ków pakietów analizowanych}.

\paragraph{Number of Classes and Interfaces / Class count (Cc)}~\\
Liczba klas konkretnych, klas abstrakcyjnych, oraz interfejsów w pakiecie jest miar¹ rozszerzalnoœci pakietu.

\paragraph{Concrete Classes (Crc)}~\\
Liczba klas konkretnych w pakiecie. Na podstawie tej metryki jesteœmy w stanie okreœliæ jak¹ czêœæ pakietu stanowi implementacja / kod wykonywany.

\paragraph{Abstract Classes (Ac)}~\\
Liczba klas abstrakcyjnych i interfejsów w pakiecie. Wartoœæ tej metryki pozwala nam stwierdziæ jak¹ czêœæ pakietu stanowi¹ abstrakcje projektowe.  

\paragraph{Total Size (Ts)}~\\
Rozmiar ca³kowity. Suma rozmiarów wszystkich klas z pakietu. Dziêki tej metryce, w odró¿nieniu od liczby klas, mo¿na dok³adniej zobrazowaæ faktyczny rozmiar pakietu.

\paragraph{Largest Class Size (Lcs)}~\\
Rozmiar najwiêkszej klasy z pakietu. Ta metryka pozwala w ³atwy sposób wskazaæ pakiety, w których znajduj¹ siê klasy o zbyt du¿ej z³o¿onoœci - byæ mo¿e wymagaj¹ce refaktoryzacji.

\paragraph{Average Size (As)}~\\
Œredni rozmiar klas. Liczony jako œrednia arytmetyczna rozmiaru klas z dzieleniem ca³kowitym. Metryka pozwala na ogólne zobrazowanie rozmiaru pakietu ze wzglêdu na rozmiar klas, a nie liczbê.

\begin{equation}
As = Ts / Cc
\end{equation}

\paragraph{Afferent Couplings (Ca)}~\\
Liczba innych pakietów, które polegaj¹ na klasach z danego pakietu. Metryka wyra¿a odpowiedzialnoœæ (ang. \textit{responsibility}) danego pakietu.

\paragraph{Efferent Couplings (Ce)}~\\
Liczba innych pakietów, na których polegaj¹ klasy z danego pakietu. Metryka wyra¿a zale¿noœæ (ang. \textit{dependency}) danego pakietu.

\paragraph{Abstractness (A)}~\\
Stosunek liczby interfejsów i klas abstrakcyjnych do liczby wszystkich klas z danego pakietu. Metryka przyjmuje wartoœci z przedzia³u od $0$ do $1$, gdzie $0$ oznacza pakiet w pe³ni konkretny, a $1$ pakiet ca³kowicie abstrakcyjny.

\begin{equation}
A = Ac / Cc
\end{equation}

\paragraph{Instability (I)}~\\
Stosunek liczby powi¹zañ eferentnych do liczby wszystkich powi¹zañ pakietu. Metryka wyra¿a podatnoœæ pakietu na zmiany. Przyjmuje wartoœci z przedzia³u od $0$ do $1$, gdzie $0$ oznacza pakiet w pe³ni stabilny (nie zmienia siê w wyniku zmian innych pakietów), a $1$ oznacza pakiet ca³kowicie niestabilny (zale¿ny od pozosta³ych).

\begin{equation}
I = Ce / (Ce + Ca)
\end{equation}

\paragraph{Distance from the Main Sequence (D)}~\\
Odleg³oœæ od idealnej linii równania $A + I = 1$. Zgodnie z za³o¿eniami dobrych praktyk projektowych \cite{b:metrics}, pakiety powinny byæ abstrakcyjne lub niestabilne. Pakiety osadzone na linii tego równania zachowuj¹ odpowiedni balans pomiêdzy abstrakcj¹ a stabilnoœci¹. Przyjmuje wartoœci z przedzia³u od $0$ do $1$, gdzie $0$ oznacza pakiet zgodny z dobrymi praktykami, a $1$ oznacza pakiet mo¿liwie najdalej oddalony od idealnego równania.

\paragraph{Abstract or Instable (AoI)}~\\
Metryka wyra¿a balans pakietu pomiêdzy abstrakcj¹, a niestabilnoœci¹ - stwierdza, czy w danym pakiecie przewa¿a abstrakcyjnoœæ, czy niestabilnoœæ - zgodnie z za³o¿eniami o odleg³oœci od idealnej sekwencji. Ta miara pozwala podzieliæ pakiety ze wzglêdu na ich charakter. Przyjmuje wartoœci od $-1$ do $1$, gdzie $-1$ oznacza pakiet, w którym przewa¿a niestabilnoœæ, a $1$ oznacza pakiet zdominowany przez abstrakcjê.

\begin{equation}
AoI = A - I
\end{equation}

\paragraph{Total Bugs (Tb)}~\\
Liczba usterek, które zosta³y wykryte wewn¹trz pakietu. Jest to metryka za pomoc¹ której w czytelny sposób mo¿na wizualizowaæ jakoœæ kodu.

\section{Statystyki historyczne}\label{s:model-history}

Chc¹c badaæ projekt pod k¹tem zmian zachodz¹cych w jego kodzie Ÿród³owym, pos³ugujê siê wybranymi statystykami historycznymi pakietów. Na podstawie tych danych mo¿na wnioskowaæ na temat charakteru poszczególnych fragmentów kodu i ich roli w projekcie. Ponadto, pos³uguj¹c siê informacjami historycznymi jestem w stanie przewidywaæ, które elementy mog¹ podlegaæ czêstym zmianom w przysz³oœci \cite{b:historical-metrics}.

\paragraph{Authors Count (Auc)}~\\
Liczba autorów, którzy wprowadzali zmiany do danego pakietu na podstawie historii z systemu kontroli wersji. Pakiety, nad którymi pracowa³a du¿a liczba autorów mog¹ zawieraæ istotn¹ funkcjonalnoœæ projektu.

\paragraph{Total Commits (Tcm)}~\\
Liczba wszystkich zatwierdzonych zmian (ang. \textit{commit})\footnote{Pojedyncze zatwierdzenie zmian, lub inaczej \textit{``commit''} w systemie kontroli wersji mo¿e dotyczyæ kilku plików z kodem, w których wprowadzono zmiany wdra¿ane do systemu kontroli wersji.} w systemie kontroli wersji, które dotyczy³y danego pakietu. Metryka wskazuje na z³o¿onoœæ danego pakietu. Kod, w którym wykonywano wiele zmian prawdopodobnie:

\begin{itemize}
\item dotyczy jednej z g³ównych funkcjonalnoœci projektu - jest stale rozwijany
\item jest podatny na zmiany / usterki - wymaga czêstej refaktoryzacji
\end{itemize}

\paragraph{Last Commit (Lcm)}~\\
Data ostatniej zmiany w systemie kontroli wersji. Dla u¿ytkownika mo¿e wskazywaæ hermetyczny charakter pakietu - kod, który od d³ugiego czasu nie by³ zmieniany, prawdopodobnie:

\begin{itemize}
\item jest solidny i nie wymaga poprawek,
\item nie dotyczy ¿adnej g³ównej, rozwijanej w projekcie funkcjonalnoœci,
\item jest kodem, który trudno bêdzie zmieniæ w przysz³oœci
\end{itemize}

\section{Droga do wizualizacji}\label{s:model-analysis}

Zaproponowany w tym rozdziale model oprogramowania pozwoli³ wyznaczyæ listê kroków koniecznych do wykonania wizualizacji wybranego projektu:

\begin{enumerate}
\item Rekonstrukcja grafu - odtworzenie struktury programu komputerowego na podstawie plików z kodem Ÿród³owym.
\item Przeszukiwanie usterek i uzupe³nienie modelu o zestaw wykrytych b³êdów w ka¿dym z wierzcho³ków.
\item Wyliczenie wartoœci metryk i uzupe³nienie modelu o informacje jakoœciowe dla ka¿dego z wierzcho³ków.
\item Analiza repozytorium projektu i uzupe³nienie modelu o informacje historyczne dla ka¿dego z wierzcho³ków.
\item Przygotowanie modelu do wizualizacji - zmapowanie elementów modelu i ich atrybutów na konkretne obiekty graficzne wed³ug wybranej metody wizualizacji.
\end{enumerate}

\section{Wizualizacja modelu - realizacja za³o¿eñ}

Przy pomocy zaproponowanego modelu opartego na grafie, by³em w stanie przeprowadziæ wizualizacjê kodu projektu w postaci grafowej [sekcja \ref{s:motivation-graph}]. Dobór metryk i manipulacja elementami graficznymi pozwoli³a mi na rozszerzenie wizualizacji grafowej i utworzenie na jej podstawie wizualizacji konstelacyjnej [sekcja \ref{s:motivation-constellation}]. Informacje historyczne o danym projekcie s¹ podstaw¹ do wykorzystania mapy termicznej [sekcja \ref{s:motivation-heatmap}].

 Poprzez odpowiedni¹ modyfikacjê œrodków wyrazu takich jak rozmiar, kolor, kszta³t wierzcho³ków oraz d³ugoœæ krawêdzi mog³em wyraziæ wartoœci wybranych metryk.

\begin{description}
\item[Rozmiar wierzcho³ka (iloœæ)] - pos³uguj¹c siê tym parametrem, mog³em w naturalny sposób odzwierciedlaæ iloœciow¹ charakterystykê kodu. Osoba ogl¹daj¹ca wizualizacjê jest w stanie ³atwo skojarzyæ wielkoœæ wierzcho³ka z liczb¹ klas w pakiecie lub ca³kowit¹ liczb¹ linii kodu.
\item[Kolor wierzcho³ka (jakoœæ)] - pozwoli³ zobrazowaæ jakoœæ wizualizowanego kodu, zw³aszcza zestawiaj¹c kolory ze skali od czerwonego do zielonego. Osoba ogl¹daj¹ca wizualizacjê mo¿e rozpoznaæ czerwone wierzcho³ki jako pakiety niskiej jakoœci, a zielone wysokiej. Oprócz jakoœci, kolor mo¿e równie¿ oddawaæ charakterystykê badanego elementu. Przyk³adowo wierzcho³ki pakietów bibliotecznych mog¹ byæ wyró¿nione od pozosta³ych przez sta³y kolor szary, a wierzcho³ki katalogowe kolor niebieski.
\item[Temperatura wierzcho³ka (aktywnoœæ)] - stanowi³a pomocniczy sposób wyrazu i pos³u¿y³a do zobrazowania statystyk historycznych danego pakietu - osoba ogl¹daj¹ca wizualizacjê mo¿e rozpoznaæ wierzcho³ki gor¹ce jako “aktywne”, a ch³odne jako stabilne, niezmienne. 
\item[D³ugoœæ krawêdzi (zale¿noœæ)] - pozwoli³a w ³atwy sposób zobrazowaæ si³ê powi¹zania miêdzy poszczególnymi elementami. Wierzcho³ki znajduj¹ce siê blisko siebie w znormalizowanym grafie, s¹ od siebie silnie zale¿ne, a wierzcho³ki oddalone nie maj¹ mocnych powi¹zañ.
\end{description}


% ------------------------------------------------------------------------------
% ROZDZIA£ APLIKACJA
% ------------------------------------------------------------------------------
\chapter{Narzêdzie Shimmering Constellations}\label{c:software}

W tym rozdziale opiszê budowê oraz dzia³anie stworzonej przeze mnie aplikacji Shimmering Constellations, która ³¹czy techniki wizualizacji grafowej i konstelacyjnej z wykorzystaniem mapy termicznej, bazuj¹c na modelu opisanym w rozdziale \ref{c:model}.

\section{Architektura aplikacji}\label{r:architektura}
\subsection{Zr¹b i technologia}

Technologia, któr¹ uzna³em za odpowiedni¹ dla mojej aplikacji to Java EE. Argumenty, które przyczyni³y siê do podjêcia tej decyzji to dostêpnoœæ szerokiej gamy bibliotek analizy kodu Ÿród³owego, rozbudowane narzêdzia wizualizacyjne dzia³aj¹ce w œrodowisku przegl¹darki internetowej (Vis.js), oraz uniwersalnoœæ i skalowalnoœæ architektury. Stworzone przeze mnie narzêdzie ma charakter aplikacji webowej opartej na frameworku Spring, wykorzystuj¹cej biblioteki JSF PrimeFaces. Œrodowiskiem uruchomieniowym aplikacji jest serwer JBoss 7, ale nie jest to wymogiem koniecznym - przy niewielkim nak³adzie pracy mo¿liwe jest uruchomienie Shimmering Constellations na dowolnym œrodowisku aplikacji webowych Java. Przy u¿yciu narzêdzia automatyzuj¹cego kompilacjê i zarz¹dzanie bibliotekami Maven, mo¿liwe jest proste dodawanie zewnêtrznych bibliotek do projektu.

Ponadto aplikacjê mo¿na w prosty sposób zintegrowaæ z dowoln¹ baz¹ danych w celu katalogowania wyników analiz.

\subsection{Struktura logiczna}

Aplikacja opiera siê na wzorcu architektonicznym Model-View-Controller w celu rozdzielenia modelu problemu i logiki dzia³ania aplikacji od interfejsu u¿ytkownika. Przyjêty przeze mnie model symulacji sk³ada siê z grafu przeanalizowanego projektu [rozdzia³ \ref{c:model}], w którym wierzcho³ki reprezentuj¹ poszczególne pakiety, a ga³êzie zale¿noœci miêdzy nimi. Widokiem aplikacji jest strona internetowa prezentuj¹ca wizualizacje oraz udostêpniaj¹ca formularze i elementy steruj¹ce dla u¿ytkownika. Kontroler aplikacji pobiera dane od u¿ytkownika, uruchamia poszczególne serwisy analizy, które konstruuj¹, a nastêpnie przetwarzaj¹ model, aby ostatecznie przedstawiæ wynik wizualizacji w widoku graficznym.

\section{Biblioteki wspomagaj¹ce analizê}

Wszystkie narzêdzia u¿yte w projekcie Shimmering Constellations s¹ stworzone w jêzyku Java i udostêpnione publicznie na licencjach otwartego oprogramowania. Dostêpnoœæ gotowych rozwi¹zañ wspomagaj¹cych analizê by³a jednym z g³ównych czynników decyduj¹cych o technologii u¿ytej w ca³ym projekcie.

\subsection{JDepend}

Narzêdzie JDepend \cite{b:jdepend} pozwala analizowaæ programy stworzone w jêzyku Java, na podstawie ich kodu skompilowanego. G³ównym zadaniem biblioteki jest przegl¹danie plików klas i zbieranie informacji dotycz¹cych metryk projektowych na poziomie pakietów. Metryki badane przez JDepend pomagaj¹ zbadaæ jakoœæ oprogramowania i wskazaæ ukryte w nim wady projektowe. Wyniki analizy mog¹ byæ prezentowane w czystej postaci tekstowej, struktury xml lub w interfejsie graficznym.

Narzêdzie nie dostarcza programistycznego API, wiêc aby móc w pe³ni wykorzystaæ mo¿liwoœci dostarczane przez JDepend, wydzieli³em kod odpowiedzialny za analizê Ÿróde³ i do³¹czy³em go do aplikacji Shimmering Constellations. Dziêki temu by³em w stanie programistycznie pozyskaæ wyniki analizy, bez koniecznoœci zbêdnej serializacji i deserializacji. Ponadto licencja, na której opublikowano JDepend pozwoli³a mi wprowadziæ zmiany w kodzie analizuj¹cym, aby dok³adniej zmierzyæ si³ê zale¿noœci miêdzy analizowanymi pakietami.

Dziêki funkcjonalnoœci dostarczanej przez JDepend, Shimmering Constellations jest w stanie zbudowaæ model analizowanego programu w postaci grafu [sekcja \ref{s:model-graph}], oraz policzyæ wartoœci niektórych podstawowych metryk projektowych [sekcja \ref{s:model-metrics}].

\subsection{Findbugs}

Findbugs \cite{b:findbugs} jest programem przeprowadzaj¹cym statyczn¹ analizê kodu skompilowanego Javy w celu detekcji potencjalnych usterek. Dzia³anie narzêdzia opiera siê na koncepcji wzorców usterek (Bug Patterns), które czêsto prowadz¹ do powstawania b³êdów. Analizator przy pomocy zaawansowanych heurystyk przeszukuje kod projektu w poszukiwaniu wzorców usterek. G³ównym celem twórców biblioteki by³o stworzenie zestawu heurystyk opartych o nauczanie maszynowe, pozwalaj¹cych na wykrywanie potencjalnych usterek z niskim wspó³czynnikiem b³êdów pierwszego rodzaju (ang. \textit{false-positive}). Autorzy podkreœlaj¹, ¿e w praktyce szansa b³êdu \textit{false-positive} jest mniejsza ni¿ 50\%.

Narzêdzie powsta³o na uniwersytecie Maryland w 2004 r. i jest stale rozwijane.

Pakiet FindBugs za³¹czony zosta³ do projektu w postaci zale¿noœci dla narzêdzia Maven. Skompilowane klasy Finndbugs 3.0.1 wraz z kodem Ÿród³owym zosta³y pobrane automatycznie i do³¹czone do œrodowiska uruchomieniowego aplikacji.

Wyniki analizy Findbugs pozwol¹ narzêdziu Shimmering Constellations wskazaæ potencjalne zagro¿enia wykryte w klasach analizowanego projektu [sekcja \ref{s:model-bugs}].

\subsection{JGit}

JGit \cite{b:jgit} jest implementacj¹ systemu kontroli wersji GIT dla jêzyka Java. Pozwala na pracê z repozytoriami GIT w œrodowisku programistycznym, ale nie udostêpnia gotowych metod pozyskuj¹cych metryki historyczne projektu. W zwi¹zku z tym proces wyliczenia odpowiednich miar musia³em zaimplementowaæ samodzielnie.

Biblioteki JGit równie¿ zosta³y dodane do projektu jako zale¿noœæ projektowa programu Maven i nie by³y przeze mnie modyfikowane.

Dziêki informacjom pozyskiwanym przez JGit, Shimmering Constellations potrafi wyliczyæ podstawowe metryki historyczne [sekcja \ref{s:model-history}] - wskazaæ ostatnio modyfikowane elementy projektu, czêsto zmieniane pakiety, oraz podaæ liczbê ich autorów.

\section{Implementacja modelu}\label{s:software-implementation}

Implementuj¹c opisany w rozdziale \ref{c:model} model grafu stara³em siê zadbaæ o zachowanie dobrych praktyk projektowych oraz wydajny dostêp do poszczególnych elementów modelu. Ze wzglêdu na krokowy charakter analizy w Shimmering Constellations [sekcja \ref{s:model-analysis}], dostêp do poszczególnych wierzcho³ków oraz krawêdzi powinien odbywaæ siê w czasie sta³ym. 

Zaimplementowany graf posiada kolekcjê wierzcho³ków i krawêdzi oraz zbiór metod umo¿liwiaj¹cych wykonywanie podstawowych czynnoœci na swojej strukturze. Wierzcho³ki przechowywane s¹ w posortowanej hash-mapie (klasa \verb+LinkedHashMap+), gdzie kluczem jest pe³na nazwa pakietu identyfikuj¹ca wierzcho³ek. Kolekcja zbieraj¹ca krawêdzie jest posortowanym hash-zbiorem (klasa \verb+LinkedHashSet+). Dziêki temu dla obu kolekcji mo¿liwa jest iteracja w ustalonej kolejnoœci, a czas wykonania kluczowych operacji jest optymalny:

\begin{itemize}
\item wyszukiwanie wierzcho³ka po nazwie: $\mathcal{O}(1)$
\item wyszukanie pakietu nadrzêdnego (ojca w drzewie pakietów) dla danego wierzcho³ka: $\mathcal{O}(1)$
\item dodawanie wierzcho³ka oraz krawêdzi drzewa pakietów: $\mathcal{O}(1)$
\item dodawanie krawêdzi zale¿noœci: $\mathcal{O}(1)$
\end{itemize}

Taki sposób implementacji modelu jest ³atwo rozszerzalny i pozwala na proste rozbudowanie funkcjonalnoœci Shimmering Constellations w przysz³oœci, np. zwiêkszenie granularnoœci przez dodanie wierzcho³ków klasowych do modelu [sekcja \ref{s:summary-future}].

\section{Przebieg dzia³ania programu - przygotowanie wizualizacji}\label{s:software-analysis}

Zebrane biblioteki i wybór implementacji modelu pozwalaj¹ na skuteczne przygotowanie danego projektu do wizualizacji [sekcja \ref{s:model-analysis}]. Kroki potrzebne do wstêpnego przeanalizowania projektu przez Shimmering Constellations podsumowuje rysunek \ref{i:software-flow}.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{architecture.png}
\caption{Schemat dzia³ania programu Shimmering Constellations}
\label{i:software-flow}
\end{figure}

Analiza projektu rozpoczyna siê w momencie, gdy u¿ytkownik zdefiniuje œcie¿kê prowadz¹c¹ do plików skompilowanych projektu i u¿yje przycisku potwierdzenia. Przed uruchomieniem wszystkich mechanizmów, u¿ytkownik mo¿e równie¿ podaæ adres zdalnego repozytorium Git lub œcie¿kê do sklonowanego repozytorium na dysku. 

\subsection{Analiza JDepend - tworzenie struktury programu}\label{r:jdepend}

Pierwszym krokiem analizy Shimmering Constellations jest uruchomienie analizatora JDepend na wskazanych plikach Ÿród³owych, b¹dŸ skompresowanych archiwach jar (analiza przez serwis JDepend mo¿e odbywaæ siê na obu rodzajach plików). Analizator JDepend bada klasy analizowanego projektu i wyniki swojego dzia³ania przedstawia w postaci posortowanej kolekcji danych dla poszczególnych pakietów. Obiekt przechowuj¹cy wyniki analizy dla konkretnego pakietu posiada istotne cechy takie jak: nazwa pakietu, liczba klas konkretnych, liczba klas abstrakcyjnych, zbiór pakietów zale¿nych (afferent couplings oraz efferent couplings). 

Otrzymuj¹c taki zestaw danych, Shimmering Constellations przegl¹da ka¿dy z wyników i buduje strukturê analizowanego programu:

\begin{itemize}
\item Dodaje do grafu projektu wszystkie wierzcho³ki reprezentuj¹ce przeanalizowane pakiety oraz biblioteki, np. \texttt{shimmer.service.impl}.
\item Dla ka¿dego z wierzcho³ków, znajduje jego rodzica w drzewie pakietów i ³¹czy go za pomoc¹ krawêdzi pakietowej, np. \texttt{shimmer.service.imp} zostaje po³¹czone z rodzicem \texttt{shimmer.service}
	\begin{itemize}
	\item Jeœli rodzic nie jest korzeniem drzewa i nie znajduje siê w grafie, oznacza to, ¿e nale¿y dodaæ do grafu wierzcho³ek katalogowy i po³¹czyæ go krawêdzi¹ pakietow¹, np. rodzicem pakietu \texttt{shimmer.service} jest \texttt{shimmer}, ale taki pakiet nie wystêpuje w projekcie, dlatego zostaje dodany jako katalog. Ten proces odbywa siê rekurencyjnie do momentu zbudowania pe³nej œcie¿ki.
	\end{itemize}
\item Dla ka¿dego wierzcho³ka dodaje do grafu krawêdzie zale¿noœci na podstawie zbioru pakietów zale¿nych. Modyfikacja wprowadzona przeze mnie do biblioteki JDepend pozwala okreœliæ si³ê tych zale¿noœci.
\end{itemize}

\paragraph{Modyfikacja Afferent Couplings (Ca)} - Analizator JDepend podaje tê wartoœæ w sposób niestandardowy - w literaturze czêœciej spotykan¹ miar¹ jest liczba klas z obcych pakietów, które polegaj¹ na klasach z pakietu danego. Modyfikacja, któr¹ wprowadzi³em do analizatora JDepend pozwala na pozyskanie dodatkowej informacji - ile klas z wybranego pakietu polega na klasach z pakietu danego. Dziêki tej modyfikacji Shimmering Constellations zna nie tylko liczbê powi¹zañ z innymi pakietami, ale te¿ ich si³ê.

\paragraph{Modyfikacja Efferent Couplings (Ce)}-  Podobnie, jak w przypadku Afferent Couplings, wartoœæ liczona jest przez analizator JDepend przy uwzglêdnieniu si³y zale¿noœci - liczby klas zale¿nych. W tym obszarze równie¿ konieczna by³a modyfikacja kodu biblioteki.

\paragraph{} Po przeprowadzeniu tego kroku analizy, Shimmering Constellations posiada odwzorowanie badanego projektu w postaci grafu [sekcja \ref{s:model-graph}] oraz zna podstawowe cechy jego wierzcho³ków (rozmiar, liczba klas abstrakcyjnych, pakiety zale¿ne itp.) i krawêdzi (si³a zale¿noœci, rodzaj powi¹zania). Dziêki tym informacjom Shimmering Constellations bêdzie w stanie przeprowadziæ wizualizacjê projektu w postaci grafu lub konstelacji.

\subsection{Analiza Findbugs - dodanie informacji o b³êdach}

Pierwsze próby u¿ycia biblioteki okaza³y siê bardzo niekorzystnie wp³ywaæ na czas wykonania g³ównej pêtli programu Shimmering Constellations i sk³oni³y mnie do szukania lepszego, bardziej wydajnego sposobu uruchamiania tego fragmentu analizy. Aby zwiêkszyæ wydajnoœæ narzêdzia, analiza wykonywana przez Findbugs uruchamiana jest w oddzielnym w¹tku, jako samodzielna instancja programu z odpowiednimi parametrami.

Parametry przekazywane analizatorowi Findbugs ró¿ni¹ siê w zale¿noœci od ustawieñ symulacji Shimmering Constellations:

\begin{itemize}
\item \texttt{effort:[min|max]} - ten parametr wy³¹cza analizy, które zwiêkszaj¹ precyzjê, ale zu¿ywaj¹ du¿e iloœci pamiêci - to ustawienie w trybie \texttt{min} pozwala przyspieszyæ dzia³anie programu kosztem iloœci wykrytych usterek
\item \texttt{relaxed} - raportowanie b³êdów nie opiera siê na sztywno zdefiniowanych heurystykach - gdy zale¿y nam na mniejszej iloœci detekcji false-positive, kosztem szybkoœci dzia³ania, Shimmering Constellations powinien zrezygnowaæ z tego parametru
\item \texttt{nested:false} - ustawienie zapobiega poszukiwaniu zagnie¿d¿onych archiwów zip i jar wewn¹trz wejœciowego katalogu projektu - ten parametr nie ulega zmianom
\item \texttt{xml} - tworzy plik wynikowy w postaci tekstu xml - ten parametr równie¿ pozostaje sta³y
\end{itemize}

Generowany przez Findbugs plik xml jest tworzony w katalogu tymczasowym, nastêpnie analizowany przez parser DOM. Report zawiera miêdzy innymi elementy reprezentuj¹ce wykryte usterki (element \texttt{BugInstance}). Shimmering Constellations parsuj¹c raport tworzy obiekty b³êdów i dodaje je do odpowiednich pakietów z grafu. Obiekt reprezentuj¹cy b³¹d posiada atrybuty nadane przez Findbugs, zgodne z przyjêtym modelem potencjalnej usterki [sekcja \ref{s:model-bugs}]:

\begin{itemize}
\item \textbf{Nazwa klasy} - nazwa klasy, w której znaleziono potencjaln¹ usterkê - na jej podstawie Shimmering Constellations przypisuje usterki do pakietów
\item \textbf{Kategoria b³êdu} - etykieta kategoryzuj¹ca rozpoznan¹ usterkê np. \textit{``bad practice''}
\item \textbf{Typ b³êdu} - identyfikator okreœlaj¹cy konkretny typ b³êdu rozpoznawanego przez Findbugs - na jego podstawie mo¿liwe jest pozyskanie dok³adniejszego opisu usterki w katalogu autorów Findbugs i naprawienie usterki
\item \textbf{Ranga b³êdu} - wartoœæ w przedziale 1-20 stwierdza poziom zagro¿enia usterki, gdzie 1 oznacza b³êdy najpowa¿niejsze, a 20 najdrobniejsze usterki
\item \textbf{Priorytet b³êdu} - ustalony przez Findbugs na podstawie rangi dla ³atwiejszego grupowania b³êdów: 
	\begin{itemize}
	\item ``scariest'' (ranga 1-4), 
	\item ``scary'' (ranga 5-9), 
	\item ``troubling'' (ranga 10-14), 
	\item ``of concern'' (ranga 15-20)
	\end{itemize}
\item \textbf{Pewnoœæ} - wartoœæ w przedziale 1-5 stwierdza stopieñ przekonania o poprawnoœci raportu, gdzie 1 oznacza b³¹d, którego pewnoœæ jest najmniejsza
\end{itemize}

Dodatkowe informacje, które Findbugs umieszcza w swoim raporcie, to statystyki pakietowe (elementy \texttt{PackageStats}). W obrêbie danego pakietu Findbugs podaje ³¹czn¹ liczbê potencjalnych usterek dla ka¿dego z 4 priorytetów b³êdów oraz listê statystyk klasowych (elementy \texttt{ClassStats}). Wa¿n¹ informacj¹ podan¹ dla ka¿dej klasy jest jej rozmiar - na jego podstawie Shimmering Constellations znajduje wartoœci metryk pakietowych, które opieraj¹ siê na rozmiarze klas - \textit{Total Size}, \textit{Largest Class Size} [sekcja \ref{s:model-metrics}].

Aby policzyæ rozmiar danej klasy, Findbugs zlicza istotne konstrukcje wp³ywaj¹ce na jej rozmiar - pola, metody, linie instrukcji. Pomijane s¹ fragmenty, które nie wp³ywaj¹ na si³ê wyrazu, np. komentarze i bia³e znaki (NCSS - \textit{Non Commenting Source Statements}).

Informacje, które nie s¹ zawarte w pliku wynikowym raportu, to s³owna nazwa typu b³êdu i tekstowy opis potencjalnej usterki - jedyn¹ informacj¹ o typie b³êdu jest jego skrótowy identyfikator. Normaln¹ procedur¹ podczas korzystania z Findbugs jest u¿ywanie dostarczonego œrodowiska GUI, gdzie za³¹czone s¹ treœci opisów poszczególnych potencjalnych b³êdów, b¹dŸ pos³ugiwanie siê indeksem rozpoznawanych potencjalnych b³êdów, zamieszczonym na stronie projektu - wyszukuj¹c opisy wed³ug skrótowego identyfikatora. Aby poprawiæ jakoœæ i wygodê korzystania z Shimmering Constellations, przygotowa³em prosty parser aktualnego indeksu potencjalnych b³êdów i wczyta³em zawarte w nim dane do s³ownika. Dziêki temu znaj¹c identyfikator typu potencjalnego b³êdu, na etapie wizualizacji mo¿liwe jest wyœwietlenie pe³nego tekstowego raportu o potencjalnych b³êdach, ³¹cznie z tekstowymi opisami potencjalnych usterek.

Analiza Findbugs nie jest niezbêdnym krokiem wymaganym do wizualizacji projektu, dlatego ze wzglêdu na czasoch³onnoœæ tej czynnoœci mo¿liwe jest jej pominiêcie na ¿yczenie u¿ytkownika. Wyniki pozyskiwane w tym kroku pozwalaj¹ narzêdziu Shimmering Constellations wskazaæ najbardziej podejrzane pakiety i przedstawiæ czytelny raport usterek [sekcja \ref{s:model-bugs}] dla ka¿dego z nich.

\subsection{Analiza JGit - dodanie informacji historycznych projektu}
Kolejnym krokiem analizy jest wydobycie metryk historycznych z repozytorium projektu. Warunkiem koniecznym do przeprowadzenia tego kroku jest posiadanie kopii reporytorium badanego projektu na dysku dostêpnym dla œrodowiska aplikacji Shimmering Constellations (JGit nie pozwala na ³atwe pozyskanie wymaganych informacji pos³uguj¹c siê jedynie zdalnym repozytorium). 
U¿ytkownik przed uruchomieniem analizy definiuje œcie¿kê dyskow¹ do repozytorium lokalnego. Jeœli u¿ytkownik nie posiada kopii repozytorium na swoim komputerze, mo¿liwe jest podanie adresu url repozytorium zdalnego, które zostanie automatycznie sklonowane do katalogu tymczasowego przez bibliotekê JGit. Ze wzglêdu na czasoch³onnoœæ klonowania, sugerowan¹ metod¹ jest przygotowanie repozytorium lokalnego przed analiz¹.

Maj¹c dostêp do repozytorium lokalnego, analizator przegl¹da wszystkie pliki podlegaj¹ce systemowi kontroli wersji i stara siê znaleŸæ w grafie projektu odpowiadaj¹ce im pakiety. Dopasowywanie odbywa siê na zasadzie analizy œcie¿ki i nazwy pliku w repozytorium. Przyk³adowo plik znajduj¹cy siê pod œcie¿k¹: \verb+src\main\java\shimmer\service\GraphService.java+  zostanie dopasowany do pakietu \texttt{shimmer.service}. Jeœli dla danego pliku dopasowanie istnieje, narzêdzie JGit przegl¹da wpisy zmian dotycz¹ce danego pliku (liczba zmian jest ograniczona do 500 wstecz) i dla danego pakietu w grafie aktualizuje liczbê wszystkich zatwierdzonych zmian, datê ostatniej zmiany oraz liczbê autorów.

Analiza JGit nie jest obowi¹zkowym krokiem w procesie badania wybranego projektu, dlatego mo¿e zostaæ pominiêta na ¿yczenie u¿ytkownika. Informacje pozyskane w tym kroku wzbogacaj¹ wiedzê na temat historii zmian projektu i pozwalaj¹ na wygenerowanie mapy termicznej metryk historycznych w widoku konstelacji.

\subsection{Wyliczenie wartoœci metryk}
W tym kroku, na podstawie stworzonego grafu projektu, wyliczane s¹ wartoœci wszystkich metryk dostêpnych w programie, które wymagaj¹ dodatkowych kalkulacji. Niektóre metryki s¹ pozyskiwane bezpoœrednio w poprzednich krokach analizy i nie wymagaj¹ obliczeñ - szczegó³y przedstawiono w tabeli \ref{t:metrics-source}.

\begin{table}[t]
\centering
	\begin{tabular}{rl}
	\hline 
	Metryka & Sposób pozyskiwania \\
	\hline
	Class count & JDepend \\
	Concrete Classes & JDepend \\
	Abstract Classes & JDepend \\
	Total Size & Findbugs \\
	Largest Class Size & Findbugs \\
	Average Size & Wyliczona \\
	Afferent / Efferent Couplings & JDepend \\
	Abstractness & Wyliczona \\
	Instability & Wyliczona \\
	Abstract or Instable & Wyliczona \\
	Distance from the Main Sequence & Wyliczona \\
	Total Bugs & Findbugs \\
	Authors Count & JGit \\
	Last Commit & JGit \\
	Total Commits & JGit \\
	\hline
	\end{tabular} 
\caption{Podzia³ obs³ugiwanych metryk ze wzglêdu na Ÿród³o ich pozyskiwania}
\label{t:metrics-source}
\end{table}

\subsection{Serializacja}
Przeanalizowane dane serializowane s¹ do formatu JSON, który jest wymagany przez biblioteki wizualizacji grafów [sekcja \ref{s:software-visualization}], zawieraj¹cego tablice wierzcho³ków i krawêdzi. 

Podczas serializacji wierzcho³ków i krawêdzi konieczne jest prze³o¿enie wartoœci metryk na odpowiednie atrybuty wizualizowanych obiektów. W zale¿noœci od ustawieñ u¿ytkownika oraz wartoœci wybranych metryk, ustalane s¹:

\begin{itemize}
\item kolor wierzcho³ków
\item rozmiar wierzcho³ków
\item temperatura wierzcho³ków
\item d³ugoœæ krawêdzi
\end{itemize}

Zamiana wartoœci metryk na parametry wizualizacyjne odbywa siê oddzielnie dla ka¿dej metryki i parametru, a ustawienie odpowiednich proporcji zosta³o dobrane eksperymentalnie.

Na tym etapie brane pod uwagê s¹ równie¿ ustawienia kalibracyjne wizualizacji. Podczas pracy z projektami o ró¿nych parametrach u¿ytkownik mo¿e mieæ potrzebê przedefiniowania domyœlnych interpretacji wartoœci - przyk³adowo, jeœli nowy projekt posiada niewiele zmian w systemie kontroli wersji, chcemy aby wizualizacja mapy termicznej by³a bardziej wra¿liwa na liczbê zmian w danym pakiecie (pakiety z pozornie niewielk¹ iloœci¹ zmian powinny byæ uznawana za “gor¹ce”).

Obiekty powsta³e w wyniku serializacji (krawêdzie i wierzcho³ki w postaci JSON) stanowi¹ dane wejœciowymi dla narzêdzi wizualizacyjnych, ale zawieraj¹ równie¿ dodatkowe metadane, z których korzysta widok aplikacji Shimmering Constellations: informacje o wartoœciach wszystkich metryk, identyfikatory wykrytych potencjalnych usterek, kategorie wierzcho³ków.

\section{Realizacja wizualizacji}\label{s:software-visualization}
\subsection{Vis.js - graf}

Podstaw¹ do wizualizacji w Shimmering Constellations jest wizualizacja grafowa. Biblioteka, która odpowiada za wizualizowanie grafu to Vis.js \cite{b:visjs}. Narzêdzie pozwala na dynamiczn¹ wizualizacjê grafu w oparciu o model dystrybucji cz¹steczek Barnes-Hut \cite{b:barnes-hut}.

Vis.js pobiera wynik analizy w postaci list wierzcho³ków i krawêdzi w formacie JSON i wyœwietla graf projektu z odpowiednimi parametrami. Prezentowana wizualizacja jest równowa¿ona w czasie rzeczywistym i pozwala u¿ytkownikowi na manipulowanie grafem - skalowanie, przesuwanie, przemieszczanie wierzcho³ków.

\subsection{Heatmaps.js - mapa termiczna}

Dope³niaj¹cym elementem wizualizacji jest mapa termiczna, która wyœwietlana jest w tle wizualizowanego grafu. Generowaniem mapy termicznej zajmuje siê biblioteka heatmap.js \cite{b:heatmapsmapsjs}. Mapa termiczna oddaje temperaturê poszczególnych wierzcho³ków.

Ze wzglêdu na dynamiczny charakter prezentacji grafu, mapa termiczna jest odœwie¿ana z ustalon¹ czêstotliwoœci¹ za ka¿dym razem, gdy graf zmienia swoje po³o¿enie, jest równowa¿ony, lub skalowany. Dziêki temu mapa termiczna adaptuje zmiany, którym ulega graf i jest w stanie dostosowaæ siê do jego dynamicznego charakteru.

Ze wzglêdu na z³o¿onoœæ obliczeniow¹ odœwie¿ania mapy termicznej, u¿ytkownik mo¿e tymczasowo zatrzymaæ jej generowanie. Ta funkcjonalnoœæ mo¿e byæ przydatna przy pracy z du¿ymi projektami, kiedy u¿ytkownik chce zmodyfikowaæ u³o¿enie grafu - tymczasowe zatrzymanie mapy termicznej pozwoli na szybkie wykonanie zmian w grafie i uruchomienie mapy termicznej ju¿ po zrównowa¿eniu grafu, bez koniecznoœci oczekiwania na aktualizacjê mapy w ka¿dym kroku. 

\subsection{Sugerowane sposoby wizualizacji metryk}

Narzêdzie Shimmering Constellations pozwala u¿ytkownikowi na samodzielny wybór sposobu obrazowania poszczególnych metryk. Jednak niektóre z metryk, ze wzglêdu na swój charakter, w oczywisty sposób s¹ lepiej wyra¿ane za pomoc¹ konkretnych œrodków. Sugerowane sposoby wizualizacji metryk przedstawiono w tabeli \ref{t:metrics-visualization}

\begin{table}[H]
\centering
	\begin{tabular}{rl}
	\hline 
	Metryka & Sugerowany sposób obrazowania\\
	\hline
	Class count & rozmiar \\
	Concrete Classes & rozmiar \\
	Abstract Classes & rozmiar \\
	Total Size & rozmiar \\
	Largest Class Size & kolor \\
	Average Size & rozmiar lub kolor \\
	Afferent / Efferent Couplings & d³ugoœæ krawêdzi \\
	Abstractness & kolor lub temperatura \\
	Instability & kolor lub temperatura \\
	Abstract or Instable & kolor \\
	Distance from the Main Sequence & kolor \\
	Total Bugs & kolor \\
	Authors Count & temperatura \\
	Last Commit & temperatura \\
	Total Commits & temperatura \\
	\hline
	\end{tabular} 
\caption{Zestawienie sugerowanych sposobów wizualizacji poszczególnych metryk}
\label{t:metrics-visualization}
\end{table}

\section{Funkcjonalnoœæ}

W tej czêœci przedstawiam zestawienie kluczowych funkcjonalnoœci dostarczanych przez stworzone przeze mnie narzêdzie.

\subsection{Dwie metody wizualizacji}

Shimmering Constellations udostêpnia dwie metody wizualizacji projektów: graf oraz konstelacja.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img1.png}
\caption{Projekt jUnit wizualizowany w postaci grafu}
\end{figure}

Wizualizacja grafowa jest podstawow¹ metod¹ pozwalaj¹c¹ w jawny sposób przedstawiæ powi¹zania pomiêdzy pakietami lub kompletne drzewo zagnie¿d¿enia pakietów. Przyjêty model oprogramowania, oparty na grafie skierowanym, jest w sposób bezpoœredni odwzorowywany w wizualizacji.

Wizualizacja konstelacyjna opiera siê na grafie projektu, jednak krawêdzie s¹ niewidoczne, a zale¿noœci miêdzy pakietami s¹ obrazowane przez odleg³oœci miêdzy wierzcho³kami. W tym widoku szczególne zastosowanie odnajduje mapa termiczna, która wzbogaca si³ê jego wyrazu o dodatkowy parametr - temperaturê wierzcho³ków.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img2.png}
\caption{Projekt jUnit wizualizowany w postaci konstelacji}
\end{figure}



\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{img3.png}
\caption{Panel zmiany metody wizualizacji}
\end{figure}

Metodê wizualizacji mo¿na zmieniæ w trakcie dzia³ania programu, bez koniecznoœci analizowania projektu na nowo.

\subsection{Czytelny raport potencjalnych usterek}

Po zaznaczeniu pakietu przez u¿ytkownika w widoku graficznym, Shimmering Constellations wyœwietla czytelny raport potencjalnych usterek wykrytych w tym pakiecie przez analizator Findbugs. Szczegó³owe opisy potencjalnych usterek pochodz¹ z oficjalnej dokumentacji Findbugs.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img4.png}
\caption{Fragment raportu potencjalnych usterek dla pakietu \texttt{org.junit.rules} z projektu JUnit}
\end{figure}

\subsection{Dynamicznie modyfikowane parametry analizy}

Shimmering Constellations pozwala u¿ytkownikowi decydowaæ o tym, jakie metryki powinny byæ wizualizowane za pomoc¹ ka¿dego z dostêpnych parametrów (d³ugoœæ krawêdzi, kolor, rozmiar i temperatura wierzcho³ków). Ponadto pozwala na wykluczenie szczególnych typów wierzcho³ków i krawêdzi z wizualizacji - przyk³adowo u¿ytkownik mo¿e zdecydowaæ o ukryciu pakietów bibliotecznych, a zdecydowaæ siê na wyœwietlenie wierzcho³ków symbolizuj¹cych katalogi pakietów.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img5.png}
\caption{Panel ustawieñ symulacji}
\end{figure}

Odpowiednio dobrane ustawienia mog¹ zale¿eæ od celu u¿ytkownika - widok grafowy z krawêdziami drzewa pakietów i wierzcho³kami katalogowymi mo¿e w œcis³y sposób oddaæ fizyczn¹ architekturê projektu. Natomiast widok konstelacyjny bez pakietów bibliotecznych i katalogów, z krawêdziami zale¿noœci o wa¿onych d³ugoœciach pozwoli skupiæ siê na jakoœci kodu zawartego w projekcie.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{img6.png}
\caption{Wybór metryki dla temperatury wierzcho³ka}
\end{figure}

Manipulacja ustawieniami odbywa siê w sposób dynamiczny, a wprowadzanie zmian do wizualizacji nie wymaga ponownej analizy projektu.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img7.png}
\caption{Krawêdzie oznaczaj¹ zale¿noœci pakietów, a ich d³ugoœæ wskazuje na si³ê zale¿noœci - liczbê klas zale¿nych. Wielkoœæ wierzcho³ków oznacza liczbê klas w pakiecie, a kolor liczbê wykrytych usterek.}
\end{figure}

\subsection{Kalibracja metryk i wizualizacji}

Przy pracy z projektami o ró¿nych charakterystykach konieczne mo¿e byæ naniesienie pewnych poprawek interpretacyjnych na mechanizm obrazowania metryk. Przyk³adowo, w projekcie uruchamianym jedynie testowo / lokalnie, mo¿emy zdecydowaæ siê na tolerowanie kilku potencjalnych usterek zg³oszonych przez Findbugs - wtedy u¿ytkownik mo¿e zwiêkszyæ próg tolerancji liczby b³êdów tak, aby kolor wierzcho³ków (jeœli u¿ywamy go do obrazowania liczby b³êdów) nie by³ zbyt jednolity. Z kolei w projekcie, który powinien cechowaæ siê du¿¹ niezawodnoœci¹, u¿ytkownik mo¿e zmniejszyæ próg tolerancji b³êdów, aby oznaczyæ wszystkie podejrzane wierzcho³ki z wiêksz¹ dok³adnoœci¹.

Podobnym ustawieniom mo¿e podlegaæ jeszcze szereg parametrów kalibracyjnych:

\begin{itemize}
\item rozmiar wierzcho³ka
\item wiek zmian
\item liczba zmian w systemie kontroli wersji
\item liczba klas w pakiecie
\item rozmiar klasy
\end{itemize}

Zmiany tych parametrów nie wymagaj¹ ponownej analizy ca³ego projektu.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img8.png}
\caption{Panel kalibracji metryk}
\end{figure}

Dynamicznym modyfikacjom mog¹ podlegaæ równie¿ ustawienia aparatu fizycznego symulacji. Odpowiednie ustawienie takich parametrów, jak sta³a grawitacyjna lub domyœlna d³ugoœæ krawêdzi (w u¿ywanym modelu fizycznym reprezentowanych jako sprê¿yny) mo¿e byæ ró¿ne dla projektów o odmiennych parametrach i nieznacznie odbiegaæ od ustawieñ domyœlnych. Zaawansowany u¿ytkownik bêdzie w stanie w pe³ni kontrolowaæ symulacjê fizyczn¹ wedle potrzeb zmieniaj¹c jej charakter na bardziej dynamiczny, statyczny, rozleg³y, skupiony itp.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img9.png}
\caption{Panel ustawieñ modelu fizycznego}
\end{figure}

\subsection{Mo¿liwoœæ zapisu i odczytu wyników analizy}

Czasoch³onnoœæ procesu analizy sk³oni³a mnie do umo¿liwienia u¿ytkownikowi zapisania wyników na dysku i odtworzenia wizualizacji bez koniecznoœci wykonywania obliczeñ. W pliku tekstowym, oprócz elementów grafu w postaci JSON zapisywane s¹ równie¿ ustawienia symulacji.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{img10.png}
\caption{Panel zapisu  / odczytu gotowego projektu}
\end{figure}

\subsection{Przystêpny interfejs u¿ytkownika}

Interfejs aplikacji zosta³ stworzony z myœl¹ o intuicyjnoœci i wygodzie u¿ytkownika. Do komunikacji z u¿ytkownikiem wykorzystano dynamiczne komponenty oparte o biblioteki Bootstrap i PrimeFaces. Ponadto, zadbano o udogodnienia wp³ywaj¹ce na jakoœæ interfejsu - pasek postêpu obliczeñ, animacje komponentów, wskaŸnik równowa¿enia grafu, gradacjê kolorystyczn¹ w odwzorowaniu wartoœci metryk.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img11.png}
\caption{Ekran g³ówny programu Shimmering Constellations}
\end{figure}

\subsection{Mo¿liwoœæ przeprowadzenia analizy czêœciowej}

Aby skróciæ czas oczekiwania na wyniki obliczeñ, u¿ytkownik mo¿e zdecydowaæ o pominiêciu niektórych etapów analizy. Analiza Findbugs (poszukiwanie potencjalnych usterek) oraz JGit (wydobywanie metryk historycznych z repozytorium) nie s¹ niezbêdne do przeprowadzenia wizualizacji - w rezultacie niektóre wyniki obliczeñ nie bêd¹ dostêpne przy symulacji. Ta funkcjonalnoœæ jest przydatna, jeœli znany jest konkretny cel wizualizacji i wiemy, jakich informacji o projekcie nie chcemy obrazowaæ - mo¿emy wtedy zrezygnowaæ z czasoch³onnych obliczeñ.  Ponadto u¿ytkownik mo¿e zmniejszyæ priorytet analizatora Findbugs - poskutkuje to szybszym dzia³aniem, ale zg³oszeniem wiêkszej iloœci b³êdów false-positive.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img12.png}
\caption{Panel umo¿liwiaj¹cy pominiêcie wybranych modu³ów}
\end{figure}

% ------------------------------------------------------------------------------
% ROZDZIA£ BADANIA
% ------------------------------------------------------------------------------
\chapter{Badanie, wyniki oraz wnioski}\label{c:research}
Aby oceniæ dzia³anie stworzonego narzêdzia oraz przejrzystoœæ rozwa¿anych przeze mnie metod wizualizacji, za rozs¹dne uzna³em zebranie opinii u¿ytkowników, do których narzêdzie jest kierowane.

W tym rozdziale przedstawiam przyk³adowe zastosowanie programu Shimmering Constellations do analizy popularnych projektów oraz ankietê, przeprowadzon¹ wœród studentów kierunku Informatyka.

\section{Przyk³ady wizualizacji}

\paragraph{Hibernate 4.3.8} - ilustracja \ref{i:research-hibernate} przedstawia wizualizacjê projektu Hibernate ORM w postaci konstelacji. Rozmiar wierzcho³ków oznacza liczbê klas w danym pakiecie, kolor wierzcho³ków obrazuje metrykê \textit{Distance From Main Sequence}, a temperatura wierzcho³ków wskazuje ostatni¹ aktywnoœæ. Widok konstelacji wyraŸnie oddziela g³ówne elementy projektu (skupione w œrodku ilustracji) od obiektów pobocznych - szare pakiety biblioteczne pojawiaj¹ siê g³ównie na obrze¿ach konstelacji. Z wizualizacji wywnioskowaæ mo¿emy, ¿e w ostatnich dniach prace w projekcie skupione by³y wokó³ okreœlonego zbioru modu³ów oznaczonego niebiesk¹ poœwiat¹ wysokiej temperatury. Wszystkie ostatnio modyfikowane fragmenty znajduj¹ siê w podga³êzi pakietu \texttt{org.hibernate.metamodel}. Ponadto program tylko kilka elementów podejrzanych o nieodpowiednie rozwi¹zania projektowe - wyraŸne skupisko czerwonych wierzcho³ków o du¿ym odchyleniu od idealnego zrównowa¿enia abstrakcji i stabilnoœci pojawia siê w okolicy pakietów \texttt{org.hibernate.internal}.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{example1.png}
\caption{Projekt Hibernate 4.3.8 w wizualizacji Shimmering Constellations}
\label{i:research-hibernate}
\end{figure}

\paragraph{jGit 3.7.1} - ilustracja \ref{i:research-jgit} pokazuje wizualizacjê projektu jGit w postaci konstelacji. Rozmiar wierzcho³ków oznacza liczbê klas w pakiecie, kolor wierzcho³ków oznacza liczbê wykrytych usterek (kalibracja ustawiona jest na ma³¹ tolerancjê b³êdów), a temperatura symbolizuje liczbê dokonywanych zmian w pakiecie (kalibracja ustawiona jest na wysoki próg aktywacji liczby zmian). W wizualizacji mo¿emy zaobserwowaæ du¿e zró¿nicowanie kodu projektu - jGit posiada pakiety zarówno bardzo du¿e (powy¿ej 220 klas) oraz bardzo ma³e. Wiêkszoœæ z najobszerniejszych pakietów posiada wykryte potencjalne usterki. Mapa termiczna w postaci niebieskiej poœwiaty sygnalizuje, ¿e w wiêkszoœci przypadków fragmenty, w których wykryto zagro¿enia s¹ jednoczeœnie elementami najczêœciej modyfikowanymi przez autorów.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{example2.png}
\caption{Projekt jGit 3.7.1 w wizualizacji Shimmering Constellations}
\label{i:research-jgit}
\end{figure}

\section{Ankieta}

Aby poznaæ opiniê u¿ytkowników na temat konstelacyjnej metody wizualizacji i porównaæ j¹ z popularn¹ wizualizacj¹ grafow¹, przeprowadzi³em ankietê wœród studentów Uniwersytetu Warszawskiego. W badaniu wziê³a udzia³ grupa 82 uczestników kursu In¿ynieria Oprogramowania, której zaprezentowano narzêdzie Shimmering Constellations. W konfiguracji testowej, narzêdzie umo¿liwia³o wyœwietlenie projektu jUnit za pomoc¹ grafu oraz konstelacji. Po obejrzeniu obu wizualizacji, uczestnicy udzielali odpowiedzi na nastêpuj¹ce pytania:

\begin{enumerate}
\item Któr¹ metodê wizualizacji preferujesz?
\item Która metoda wizualizacji wydaje Ci siê czytelniejsza?
\item Która metoda wizualizacji wydaje Ci siê bardziej estetyczna?
\item Która metoda pozwala szybciej wykryæ podejrzane elementy projektu?
\item Która z metod lepiej demonstruje architekturê projektu?
\item Bêd¹c na pozycji osoby decyzyjnej (np. Project Director decyduj¹cy o finansowaniu projekt), której metody wola³byœ u¿ywaæ do szybkiej oceny sytuacji w projekcie?
\item Bêd¹c na miejscu in¿yniera pracuj¹cego nad projektem (np. cz³onek zespo³u programistów, który refaktoryzuje kod), któr¹ z metod wybra³byœ do codziennej pracy?
\end{enumerate}

 Dobór pytañ testowych mia³ w zamyœle wykrycie wyraŸnych ró¿nic w charakterze i zastosowaniach metody konstelacyjnej i klasycznej grafowej. Wyniki badania przedstawiono na wykresie \ref{i:research-results}.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{results.png}
\caption{Wykres przedstawia wyniki przeprowadzonego badania preferencji u¿ytkowników. Na wykresie oznaczono liczbê odpowiedzi na poszczególne pytania.}
\label{i:research-results}
\end{figure}

\section{Wnioski}

Przeprowadzone badanie wykaza³o, ¿e studenci we wszystkich przypadkach chêtniej wybierali metodê grafow¹. Podejœcie grafowe jest klasyczne i jego wiêksza popularnoœæ jest zgodna z oczekiwaniami, ale wœród odpowiedzi na niektóre pytania zaobserwowaæ mo¿na zainteresowanie metod¹ konstelacyjn¹. Metoda konstelacyjna zosta³a szczególnie doceniona w pytaniach dotycz¹cych estetyki, podejmowania decyzji przez zarz¹d projektu oraz wykrywania podejrzanych elementów (w tych pytaniach konstelacja by³a preferowana przez ok. 23\% - 42\% ankietowanych).

Aby poprawiæ jakoœæ metody konstelacyjnej, mo¿liwe s¹ dalsze badania nad oczekiwaniami u¿ytkowników w stosunku do konstelacji (i innych - alternatywnych do grafu - metod wizualizacji). W szczególnoœci dobrym podejœciem by³oby przeprowadzenie badania na wiêkszej liczbie zró¿nicowanych projektów (w przeprowadzonym przeze mnie badaniu uczestnicy obserwowali wizualizacjê tylko jednego projektu o niewielkich rozmiarach) i innej grupie u¿ytkowników (studenci 2-go roku nie posiadaj¹ du¿ego doœwiadczenia projektowego).

% ------------------------------------------------------------------------------
% ROZDZIA£ PODSUOWANIE
% ------------------------------------------------------------------------------
\chapter{Podsumowanie pracy}\label{c:summary}

W pracy opisano narzêdzie do wizualizacji projektów informatycznych, którego kod udostêpniono na zasadach Open Source \cite{b:shimmer}. Program Shimmering Constellations ³¹czy w sobie techniki wizualizacji konstelacyjnej oraz grafowej ze zintegrowan¹ map¹ termiczn¹. Wizualizacja kodu pozwala nie tylko w sposób czytelny zobrazowaæ z³o¿onoœæ danego projektu, ale uwzglêdnia te¿ zachodz¹ce w nim zmiany i umo¿liwia analizê jakoœci. Skutecznoœæ wykorzystanych metod w poszczególnych obszarach zastosowañ zosta³a zweryfikowana badaniem preferencji u¿ytkowników.

\section{Perspektywy dalszego rozwoju oprogramowania}\label{s:summary-future}

Oprogramowanie Shimmering Constellations powsta³o z myœl¹ o mo¿liwoœci przysz³ego rozbudowywania jego funkcjonalnoœci. Architektura i implementacja [sekcja \ref{r:architektura} oraz \ref{s:software-implementation}] aplikacji by³y tworzone zgodnie ze sztuk¹ pragmatycznego programowania, aby umo¿liwiæ dalszy rozwój systemu i zapewniæ jego wysok¹ skalowalnoœæ. Obecnie przewidziano nastêpuj¹ce mo¿liwoœci rozwoju narzêdzia:

\paragraph{Zwiêkszenie granularnoœci:} Korzystnym krokiem w rozwoju systemu by³oby zwiêkszenie granularnoœci wizualizacji. Obecnie kod obrazowany przez Shimmering Constellations przedstawiany jest na poziomie pakietów i na tym poziomie liczona jest wiêkszoœæ dostarczanych metryk. Rozbudowanie aplikacji o analizê na poziomie poszczególnych klas wymaga³oby jedynie niewielkich zmian w analizatorze JDepend [sekcja \ref{r:jdepend}] i modelu projektu [rozdzia³ \ref{c:model}]. Biblioteka wizualizacyjna Vis.js pozwala na automatyczn¹ obs³ugê klastrowania wierzcho³ków - dziêki temu wierzcho³ki reprezentuj¹ce klasy mog³yby ³¹czyæ siê w wierzcho³ki klastrowe reprezentuj¹ce poszczególne pakiety (stan obecny). Takie rozbudowanie zwiêkszy³oby dok³adnoœæ narzêdzie Shimmering Constellations.

\paragraph{Uruchomienie aplikacji www:} Dobrym wykorzystaniem narzêdzia Shimmering Constellations mog³oby by byæ uruchomienie go w postaci us³ugi online, miêdzy innymi w celach naukowych. Uczestnicy kursu In¿ynieria Oprogramowania mogliby przy u¿yciu opisanego programu analizowaæ wybrane projekty informatyczne, a wyniki analiz zbierane w bazie danych pozwoli³yby badaæ studentom i pracownikom instytutu projekty Open Source. Taka modyfikacja, dziêki architekturze opartej na aplikacji www [sekcja \ref{r:architektura}], wymaga³aby jedynie integracji z wybran¹ baz¹ danych. 

\paragraph{Dodanie nowych metryk i modu³ów:} Naturalnym rozszerzeniem dla aplikacji Shimmering Constellations jest implementacja nowych metryk i modu³ów analizuj¹cych kod projektu. Chc¹c wzbogaciæ program o mo¿liwoœæ wizualizacji dodatkowej metryki, nale¿y rozbudowaæ model o nowe w³aœciwoœci [rozdzia³ \ref{c:model}], dodaæ odpowiedni analizator do g³ównego procesu programu [sekcja \ref{s:software-analysis}], i zadbaæ o odpowiednie obrazowanie nowej cechy [sekcja \ref{s:software-visualization}].


% ------------------------------------------------------------------------------
% DODATEK
% ------------------------------------------------------------------------------

\appendix

\chapter{Oprogramowanie Shimmering Constellations}

Oprogramowanie opisane w pracy znajduje siê na za³¹czonej p³ycie CD, pod adresem: \url{http://students.mimuw.edu.pl/~fd305199/shimmer/shimmer.zip} oraz w publicznym repozytorium: \url{https://github.com/filip-daca/shimmer}

Za³¹czona paczka zawiera kod programu Shimmering Constellations napisany w jêzyku Java. W katalogu \verb+src\+ znajduje siê kod klas programu. W katalogu \verb+etc\thesis+ umieszczono kod Ÿród³owy tego dokumentu. Plik \verb+pom.xml+ zawiera zestaw konfiguracji dla narzêdzia Maven, które mo¿e skompilowaæ program Shimmering Constellations. Skompilowany program znajdzie siê w katalogu \verb+target\+ i mo¿e zostaæ uruchomiony w œrodowisku uruchomieniowym Jboss 7.1.1.

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem{b:vissoft} Institute of Electrical and Electronics Engineers, \textit{International Workshop on Visualizing Software for Understanding and Analysis (VISSOFT)} \url{http://vissoft.dcc.uchile.cl/}

\bibitem{b:graph} Erdemir, U.; Tekin, U.; Buzluca, F., \textit{E-Quality: A graph based object oriented software quality visualization tool} Visualizing Software for Understanding and Analysis (VISSOFT), 2011 6th IEEE International Workshop on , vol., no., pp.1,8, 29-30 Sept. 2011

\bibitem{b:constellation} Fang Deng; DiGiuseppe, N.; Jones, J.A., \textit{Constellation visualization: Augmenting program dependence with dynamic information}, Visualizing Software for Understanding and Analysis (VISSOFT), 2011 6th IEEE International Workshop on , vol., no., pp.1,8, 29-30 Sept. 2011

\bibitem{b:tarantulla} J. A. Jones, M. J. Harrold, and J. Stasko., \textit{Visualization of test information to assist fault localization}, Proceedings of the International
Conference on Software Engineering, ICSE ’02, pages 467–477, New York, NY, USA, 2002. ACM.

\bibitem{b:see-soft} S. G. Eick, J. L. Steffen, and E. E. Sumner, Jr. \textit{Seesoft-a tool for visualizing line oriented software statistics.} IEEE Trans. Softw. Eng., 18:957–968, November 1992.

\bibitem{b:heatmaps} Benomar, O.; Sahraoui, H.; Poulin, P., \textit{Visualizing software dynamicities with heat maps}, Software Visualization (VISSOFT), 2013 First IEEE Working Conference on , vol., no., pp.1,10, 27-28 Sept. 2013

\bibitem{b:metrics} Martin, Robert C. \textit{Design principles and design patterns}, Object Mentor, 2000: 1-34. 

\bibitem{b:historical-metrics} Mahmoud O. Elish; Mojeeb Al-Rahman Al-Khiaty \textit{A suite of metrics for quantifying historical changes to predict future change-prone classes in object-oriented software}, Journal of Software: Evolution and Process, Volume 25, Issue 5, pages 407–437, May 2013

\bibitem{b:jdepend} Mike Clark \textit{JDepend}, 1999-2009 Clarkware Consulting, Inc. \url{http://clarkware.com/software/JDepend.html}

\bibitem{b:findbugs} David Hovemeyer; William Pugh. 2004. \textit{Finding bugs is easy}, SIGPLAN Not. 39, 12 (December 2004), 92-106

\bibitem{b:jgit} \textit{JGit}, The Eclipse Foundation, 2015 \url{http://www.eclipse.org/jgit/}

\bibitem{b:visjs} J. Jong; A. Mulder, \textit{Vis.js}, Almende B.V. 2010 - 2015, \url{http://visjs.org/} 

\bibitem{b:barnes-hut} J. Barnes and P. Hut (December 1986). \textit{A hierarchical O(N log N) force-calculation algorithm.} Nature 324 (4): 446–449.

\bibitem{b:heatmapsmapsjs} P. Wied, \textit{heatmap.js}, 2014 - 2015, \url{http://www.patrick-wied.at/static/heatmapjs/}

\bibitem{b:shimmer} F. Daca, \textit{Shimmering Constellations}, 2014 - 2015, \url{https://github.com/filip-daca/shimmer}

\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
