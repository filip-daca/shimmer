%
% Filip Daca - Praca magisterska
% Warszawa, czerwiec 2015
%
% Formatownie dokumentu - Copyright (c) 2001 by Marcin Woliñski <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie - Seweryn Kar³owicz, 05.05.2006

\documentclass{pracamgr}

\usepackage{float}
\usepackage{graphicx}
\usepackage{polski}
\usepackage[cp1250]{inputenc}
\usepackage{hyperref}

\author{Filip Daca}
\nralbumu{305199}
\title{Metody wizualizacji kodu Ÿród³owego w repozytorium wspomagaj¹ce analizê jakoœci}
\tytulang{Repository source code visualization methods supporting quality analysis}
\kierunek{Informatyka}

\opiekun{dr Robert D¹browski\\
  Instytut Informatyki\\
  }

\date{Czerwiec 2015}

\dziedzina{ 
11.3 Informatyka\\ 
}

% TODO
%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{D. Software\\
  D.127. Blabalgorithms\\
  D.127.6. Numerical blabalysis}

% TODO
\keywords{wizualizacja kodu, wizualizacja konstelacyjna, mapa termiczna, analiza projektów informatycznych, eksploracja repozytorium, narzêdzia in¿ynierii oprogramowania}

\newtheorem{defi}{Definicja}[section]

\begin{document}
\maketitle

% TODO
\begin{abstract}
Mo¿liwoœæ przejrzystej wizualizacji repozytorium du¿ego projektu informatycznego jest kluczowa przy analizie jego dotychczasowego rozwoju. Aby uskuteczniæ proces analizy, wizualizacja, oprócz obrazowania kodu, powinna uwzglêdniaæ metryki lub miary oceniaj¹ce elementy badanego systemu. Mo¿liwoœæ ujêcia takiej wizualizacji w ramach systemu kontroli wersji danego projektu pozwala skutecznie œledziæ rozwój oprogramowania i w szczególnoœci przewidywaæ niepo¿¹dane usterki. W pracy przedstawione zostan¹ ró¿ne metody wizualizacji kodu ze szczególnym naciskiem na wizualizacjê repozytorium i przysz³¹ analizê jakoœci. Wybrane elementy zostan¹ zaimplementowane w narzêdziu do analizy i wizualizacji kodu, które zostanie udostêpnione na zasadach Open Source.
\end{abstract}

\tableofcontents
\listoffigures
\listoftables

% ------------------------------------------------------------------------------
% ROZDZIA£ WSTÊP
\chapter*{Wprowadzenie}
\addcontentsline{toc}{chapter}{Wprowadzenie}

% TODO
\paragraph{TODO:}
\textit{Tutaj opiszê krótko kontekst pracy i g³ówne zainteresowanie. W kolejnych akapitach opiszê zawartoœæ poszczególnych rozdzia³ów oraz dodatku.}

% ------------------------------------------------------------------------------
% ROZDZIA£ MOTYWACJA
\chapter{Motywacja}\label{r:motywacja}

% TODO
\paragraph{TODO:}
\textit{W tym rozdziale opiszê motywacjê stoj¹c¹ za powstaniem tej pracy. G³ówn¹ motywacj¹ jest chêæ po³¹czenia trzech aspektów wizualizacji w jednym narzêdziu: obraz struktury programu, jakoœæ kodu, zmiany w projekcie. Mo¿liwe, ¿e zrezygnujê z tego rozdzia³u?}

% ------------------------------------------------------------------------------
% ROZDZIA£ METODY
\chapter{Stosowane metody wizualizacji}\label{r:metody}

Jako Ÿród³o prac dotycz¹cych wspó³czesnych metod wizualizacji kodu przyj¹³em konferencjê naukow¹ Visualizing Software for Understanding and Analysis -  VISSOFT 2011.

Przegl¹daj¹c stosowane metody wizualizacji kodu stara³em siê zwracaæ uwagê na trzy interesuj¹ce dla mnie aspekty:

\begin{itemize}
\item Opis metody obrazowania kodu projektu - w jaki sposób wizualizowane jest oprogramowanie? 
\item Mo¿liwoœæ wizualizacji jakoœci kodu - czy opisywana metoda pozwala na obrazowania miar jakoœci? 
\item Uwzglêdnienie analizy historycznej kodu - czy wizualizacja uwzglêdnia i obrazuje zmiany w projekcie?
\end{itemize}

W pracach opublikowanych na konferencji VISSOFT nie znalaz³em ¿adnego artyku³u, który uwzglêdnia³ wszystkie trzy z wy¿ej wymienionych aspektów, jednak uda³o mi siê znaleŸæ kilka prac, które w ciekawy sposób poruszaj¹ czêœæ z nich, a pomys³y z tych prac zebrane w jedn¹ ca³oœæ mog³yby z³o¿yæ siê na przydatne narzêdzie wspieraj¹ce sztukê in¿ynierii oprogramowania.

\section{Graf}

W swojej pracy \cite{bib_graph} U. Erdemir, U. Tekin i F. Buzluca proponuj¹ standardow¹ metodê wizualizacji kodu w postaci grafu. Stworzone przez nich narzêdzie wydobywa metryki jakoœciowe z kodu Ÿród³owego analizowanego oprogramowania i 

%TODO
\paragraph{TODO:}
\textit{Tutaj opiszê dok³adniej abstrakt omawianej pracy.}

\subsection{Wykorzystane techniki}

%TODO
\paragraph{TODO:}
\textit{Tutaj wypunktujê i opiszê stosowane przez autorów techniki, np. manipulacja kszta³tem wierzcho³ka w grafie.}

\paragraph{TODO:}
\textit{Umieszczê ilustracjê z pracy autorów.}

\subsection{Podsumowanie grafu}

Metoda zaproponowana przez autorów jest prosta w interpretacji i zrozumia³a dla u¿ytkownika. Za pomoc¹ grafu mo¿na w ³atwy sposób wizualizowaæ poszczególne cechy projektu nanosz¹c kolory na wybrane wierzcho³ki / krawêdzie. Autorzy potwierdzili eksperymentalnie, ¿e zastosowana przez nich metoda mo¿e byæ u¿yta do detekcji niedoskona³oœci projektowych i fragmentów kwalifikuj¹cych siê do refaktoryzacji.

\paragraph{TODO:}
\textit{Wspomnê ¿e praca nie porusza wszystkich trzech interesuj¹cych mnie aspektów - brak analizy zmian projektu}
% Przyk³ady zaprezentowane przez autorów by³yby bardziej czytelne, gdyby wyraŸnie zaznaczyæ wierzcho³ki grafu.

\section{Konstelacja}

Ciekaw¹ metod¹ zaproponowan¹ przez F. Deng, N. DiGgiuseppe i J. A. Jones \cite{bib_const} jest konstelacja. Ten sposób wizualizacji zosta³ opracowany w celu ³atwego wykrywania konkretnych fragmentów kodu oraz wizualnej separacji elementów nieinteresuj¹cych od istotnych (przyk³adowo klas wadliwych od prawid³owych).

\subsection{Zasada budowy wizualizacji konstelacyjnej}

Wizualizacja konstelacyjna opiera siê w du¿ej mierze na wizualizacji grafowej. W swojej pracy autorzy opisuj¹ kroki potrzebne do przetworzenia grafu zale¿noœci (o dowolnej granularnoœci) w konstelacjê. S¹ to kolejno:

\paragraph{Ukrycie krawêdzi:}
Dla lepszej skalowalnoœci uk³adu i interpretacji u¿ytkownika, w grafie zale¿noœci projektu nale¿y zrezygnowaæ z wizualizacji krawêdzi.

\paragraph{Uproszczenie wierzcho³ków:}
Dla lepszej rozszerzalnoœæ interpretacyjnej, wierzcho³ki powinny byæ wizualizowane jako pojedynczy punkt.

\paragraph{Kolorowanie wierzcho³ków na podstawie meta-danych:}
Dla obrazowania konkretnego problemu, wierzcho³ki powinny zostaæ pokolorowane wed³ug wybranych meta-danych. Przyk³adowo, jeœli interesuje nas jakoœæ wizualizowanego kodu, mo¿emy pos³ugiwaæ siê informacj¹ o jakoœci / liczbie usterek danego wierzcho³ka. Autorzy w swoich przyk³adach u¿yli informacji o podejrzanych instrukcjach pochodz¹cych z narzêdzia Tarantula rozwijanego w ramach prac nad detekcj¹ usterek \cite{bib_taran}

\paragraph{Nadanie si³ krawêdziom:}
Dla u³atwienia interpretacji i lepszego powi¹zania kontekstowego wizualizowanych wierzcho³ków, krawêdzie powinny swoj¹ d³ugoœci¹ reprezentowaæ si³ê powi¹zania. Autorzy zastosowali w swoich przyk³adach informacje pozyskane przy dynamicznej analizie projektu.

\paragraph{Równowa¿enie / klastrowanie:}
Aby metoda pozwala³a jeszcze dok³adniej interpretowaæ wizualizacjê pod k¹tem konkretnego problemu, konstelacja mo¿e zrównowa¿yæ po³o¿enie wierzcho³ków. Zamys³em autorów by³o wizualne rozdzielenie grup wierzcho³ków o wspólnych cechach. W swoim przyk³adzie autorzy wprowadzili kategoryzowanie uruchomieñ, aby wzbogaciæ informacje z dynamicznej analizy.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{bib1.png}
\caption{Projekt Gzip wizualizowany w postaci konstelacji podany jako przyk³ad autorów pracy \cite{bib_const}}
\end{figure}

\subsection{Badania potwierdzaj¹ce skutecznoœæ konstelacji}

Autorzy pracy przeprowadzili badania, które potwierdzi³y skutecznoœæ metody konstelacyjnej. W teœcie wziê³o udzia³ 30 studentów informatyki uniwersytetu w Kalifornii, o ró¿nym stopniu doœwiadczenia. Do testu przygotowano 4 projekty informatyczne, w których kodzie umieszczono co najmniej 20 losowych usterek. Nastêpnie na podstawie wizualizacji konstelacyjnej oraz mapy kodu uczestnicy badania mieli wskazaæ przypuszczaln¹ lokalizacjê usterki przez oznaczenie odpowiednich elementów kodu. Obie wizualizacje by³y oznaczone kolorami na podstawie meta-danych dostarczonych przez narzêdzie analizuj¹ce jakoœæ kodu i obrazowa³y kod na poziomie instrukcji. Dziêki temu autorzy byli w stanie w mierzalny sposób stwierdziæ, jaka objêtoœæ kodu jest podejrzana wed³ug uczestników badania. W wyniku testu autorzy wykazali, ¿e w ka¿dym przypadku wizualizacja konstelacyjna wymaga³a od u¿ytkowników przejrzenia znacznie mniejszej liczby linii kodu ni¿ w przypadku wizualizacji mapy SeeSoft.

\subsection{Wnioski i podsumowanie konstelacji}

Wizualizacja konstelacyjna jest metod¹, która dobrze nadaje siê wielu zastosowañ in¿ynierii oprogramowania i mo¿na j¹ przeprowadziæ uzupe³niaj¹c graf wizualizowanego projektu o odpowiednie metadane. Skutecznoœæ metody potwierdzono badaniami, w których wykazano, ¿e programiœci potrzebuj¹ mniej czasu na identyfikacjê usterek w kodzie, kiedy pos³uguj¹ siê konstelacj¹, w porównaniu do mapy dokumentu.

\section{Mapa termiczna}

Praca autorstwa O. Benomar, H. Sahraoui, P. Poulin \cite{bib_heat} przedstawia kilka interesuj¹cych zastosowañ mapy termicznej w wizualizacji projektów. W swojej pracy autorzy opisuj¹ metodê wizualizacji kodu w postaci miast i budynków, a wykorzystana w tle mapa termiczna s³u¿y do oznaczania dynamiki projektu. Istotnym zamys³em autorów by³o dok³adne opisanie rozwi¹zañ graficznych u¿ytych przy integracji mapy z g³ówn¹ wizualizacj¹.

\subsection{Zastosowania}

Mapy termiczne s¹ dwuwymiarowymi obiektami wykorzystuj¹cymi metaforê ciep³a do reprezentowania intensywnoœci lub wa¿noœci poszczególnej cechy. W zale¿noœci od rozk³adu wybranej cechy, kolory mapy termicznej interpoluj¹ ze sob¹ tworz¹c wyraŸnie obserwowalne otoczenia o wiêkszym zagêszczeniu danej w³aœciwoœci. Taki charakter map termicznych mo¿e mieæ zastosowanie w wizualizacji zmian zachodz¹cych w projekcie. Autorzy rozwa¿aj¹ przyk³ady oparte na historycznych w³aœciwoœciach kodu:

\paragraph{Czas zmian:} Zastosowanie mapy termicznej do obrazowania wieku ostatniej zmiany danego fragmentu kodu. Autorzy wizualizuj¹c projekt w postaci miast, klasy programu przedstawiali w formie budynków. Budynki na tle o wysokiej temperaturze oznacza³y klasy, które by³y niedawno modyfikowane. Taka wizualizacja umo¿liwia analizê zagadnieñ: 

\begin{itemize}
\item Nad jak¹ czêœci¹ projektu trwaj¹ aktualnie prace? 
\item Które elementy projektu nie by³y od dawna zmieniane?
\end{itemize}

\paragraph{Iloœæ zmian:} U¿ycie mapy termicznej do oznaczenia ca³kowitej liczby zmian danego fragmentu kodu. Autorzy wysok¹ temparatur¹ oznaczaj¹ klasy czêsto modyfikowane. Takie podejœcie pozwala znaleŸæ odpowiedzi na pytania:

\begin{itemize}
\item Która klasa / fragment oprogramowania jest najpopularniejszy? 
\item Które elementy projektu ulegaj¹ czêstym zmianom, a które pozostaj¹ niezmodyfikowane?
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{bib2.png}
\caption{Projekt JHotDraw wizualizowany w postaci miasta przy u¿yciu mapy termicznej w przyk³adzie z pracy \cite{bib_heat}}
\end{figure}

\subsection{Wnioski i podsumowanie map termicznych}

Mapa termiczna mo¿e byæ dodatkowym elementem wizualizacji, który w dobry sposób oddaje dynamikê projektu. Rozmyty charakter obrazowania termicznego, szczególnie wykorzystany w tle konkretnej wizualizacji, rozszerza otoczenie pojedynczych elementów i przyczynia siê do powstawania obszarów o konkretnych w³aœciwoœciach. Przyk³adowo - obszary o wiêkszej temperaturze mog¹ obrazowaæ skupiska kodu czêsto modyfikowanego.

% ------------------------------------------------------------------------------
% ROZDZIA£ APLIKACJA
\chapter{Narzêdzie Shimmering Constellations}\label{r:aplikacja}

Wybrane elementy metod wizualizacji postanowi³em zaimplementowaæ w narzêdziu open-source, które w przystêpny sposób pozwoli³oby u¿ytkownikowi wizualizowaæ projekty informatyczne z uwzglêdnieniem analizy jakoœciowej.

W tym rozdziale opiszê budowê oraz dzia³anie aplikacji Shimmering Constellations, która ³¹czy techniki wizualizacji grafowej i konstelacyjnej z wykorzystaniem mapy termicznej.

\section{Architektura aplikacji}\label{r:architektura}
\subsection{Zr¹b i technologia}

Technologia, która wyda³a mi siê odpowiednia dla mojego rozwi¹zania to Java EE. Argumenty, które przyczyni³y siê do podjêcia tej decyzji to dostêpnoœæ szerokiej gamy bibliotek analizy kodu Ÿród³owego, rozbudowane narzêdzia wizualizacyjne dzia³aj¹ce w œrodowisku przegl¹darki internetowej (vis.js), oraz uniwersalnoœæ i skalowalnoœæ architektury. Stworzone przeze mnie narzêdzie ma charakter aplikacji webowej opartej na frameworku Spring, wykorzystuj¹cej biblioteki JSF PrimeFaces. Œrodowiskiem uruchomieniowym aplikacji jest serwer JBoss 7, ale nie jest to wymogiem koniecznym - przy niewielkim nak³adzie pracy mo¿liwe jest uruchomienie Shimmer na dowolnym œrodowisku aplikacji webowych JEE. Przy u¿yciu narzêdzia automatyzuj¹cego Maven, mo¿liwe jest proste dodawanie zewnêtrznych bibliotek do projektu.

Dziêki tym za³o¿eniom projektowym, aplikacja mo¿e byæ w ³atwy sposób uruchomiona na serwerze uczelni i udostêpniona dla studentów oraz naukowców poprzez interfejs przegl¹darki internetowej - bez koniecznoœci instalacji ca³ego pakietu na swoim komputerze. Ponadto aplikacjê mo¿na w prosty sposób zintegrowaæ z dowoln¹ baz¹ danych w celu katalogowania wyników analiz.

\subsection{Struktura logiczna}

Aplikacja opiera siê na wzorcu architektonicznym Model-View-Controller w celu rozs¹dnego rozdzielenia logiki problemu od interfejsu u¿ytkownika. Przyjêty przeze mnie model symulacji sk³ada siê z grafu przeanalizowanego projektu, w którym wierzcho³ki reprezentuj¹ poszczególne pakiety, a ga³êzie zale¿noœci miêdzy nimi. Widokiem aplikacji jest strona internetowa prezentuj¹ca wizualizacjê oraz udostêpniaj¹ca formularze i elementy steruj¹ce dla u¿ytkownika. Kontroler aplikacji pobiera dane od u¿ytkownika, uruchamia poszczególne serwisy analizy, które konstruuj¹ a nastêpnie przetwarzaj¹ model, aby ostatecznie przedstawiæ wynik wizualizacji w widoku.

\section{Biblioteki wspomagaj¹ce analizê}

Wszystkie narzêdzia u¿yte w projekcie Shimmer s¹ stworzone w jêzyku Java i udostêpnione publicznie na licencjach otwartego oprogramowania. Dostêpnoœæ gotowych rozwi¹zañ wspomagaj¹cych analizê by³a jednym z g³ównych czynników decyduj¹cych o technologii u¿ytej w ca³ym projekcie.

\subsection{JDepend}

%TODO
\paragraph{TODO:}
\textit{Zacytujê pracê na temat JDepend}

Narzêdzie JDepend pozwala analizowaæ programy stworzone w jêzyku Java, na podstawie ich kodu skompilowanego. G³ównym zadaniem biblioteki jest przegl¹danie plików klas i zbieranie informacji dotycz¹cych metryk projektowych na poziomie pakietów. Metryki badane przez JDepend pomagaj¹ zbadaæ jakoœæ oprogramowania i wskazaæ ukryte w nim wady projektowe. Wyniki analizy mog¹ byæ prezentowane w czystej postaci tekstowej, struktury xml lub w interfejsie graficznym.

Narzêdzie nie dostarcza programistycznego API, wiêc aby móc w pe³ni wykorzystaæ mo¿liwoœci dostarczane przez JDepend, wydzieli³em kod odpowiedzialny za analizê Ÿróde³ i do³¹czy³em go do aplikacji Shimmer. Dziêki temu by³em w stanie programistycznie pozyskaæ wyniki analizy, bez koniecznoœci zbêdnej serializacji i deserializacji. Ponadto licencja, na której opublikowano JDepend pozwoli³a mi wprowadziæ zmiany w kodzie analizuj¹cym, aby dok³adniej zmierzyæ si³ê zale¿noœci miêdzy analizowanymi pakietami.

Dziêki funkcjonalnoœci dostarczanej przez JDepend, Shimmer jest w stanie zbudowaæ model analizowanego programu w postaci grafu, oraz policzyæ wartoœci niektórych podstawowych metryk projektowych.

\subsection{Findbugs}

%TODO
\paragraph{TODO:}
\textit{Zacytujê pracê na temat Findbugs}

Findbugs jest programem przeprowadzaj¹cym statyczn¹ analizê kodu skompilowanego Javy w celu detekcji potencjalnych usterek. Dzia³anie narzêdzia opiera siê na koncepcji wzorców usterek (Bug Patterns), które czêsto prowadz¹ do powstawania b³êdów. Analizator przy pomocy zaawansowanych heurystyk przeszukuje kod projektu w poszukiwaniu wzorców usterek. G³ównym celem twórców biblioteki by³o stworzenie zestawu heurystyk opartych o nauczanie maszynowe, pozwalaj¹cych na wykrywanie potencjalnych usterek z niskim wspó³czynnikiem false-positive. Autorzy podkreœlaj¹, ¿e w praktyce szansa detekcji false-positive jest mniejsza ni¿ 50\%.

Narzêdzie powsta³o na uniwersytecie Maryland w 2004 r. i jest stale rozwijane.

Pakiet FindBugs za³¹czony zosta³ do projektu w postaci zale¿noœci dla narzêdzia Maven. Skompilowane klasy Finndbugs 3.0.1 wraz z kodem Ÿród³owym zosta³y pobrane automatycznie i do³¹czone do œrodowiska uruchomieniowego aplikacji.

Wyniki analizy Findbugs pozwol¹ narzêdziu Shimmer wskazaæ potencjalne zagro¿enia wykryte w klasach analizowanego projektu.

\subsection{JGit}

JGit jest wydajn¹ implementacj¹ systemu kontroli wersji GIT dla jêzyka Java. Pozwala na pracê z repozytoriami GIT w œrodowisku programistycznym, ale nie udostêpnia gotowych metod pozyskuj¹cych metryki historyczne projektu. W zwi¹zku z tym proces wyliczenia odpowiednich miar musia³em zaimplementowaæ samodzielnie.

Biblioteki JGit równie¿ zosta³y dodane do projektu jako zale¿noœæ projektowa programu Maven i nie by³y przeze mnie modyfikowane.

Dziêki informacjom pozyskiwanym przez JGit, Shimmer potrafi wyliczyæ podstawowe metryki historyczne - wskazaæ ostatnio modyfikowane elementy projektu, czêsto zmieniane pakiety, oraz podaæ liczbê ich autorów.

\section{Model}\label{r:model}
\subsection{Model logiczny}

Przyjêty przeze mnie model analizowanego projektu ma strukturê grafu nieskierowanego, w którym wyró¿niamy kilka rodzajów wierzcho³ków oraz krawêdzi

\paragraph{Wierzcho³ki}~\\
\begin{itemize}
\item Wierzcho³ki pakietowe - Package nodes - reprezentuj¹ pakiety analizowanego projektu
	\begin{itemize}
	\item Wierzcho³ki pakietów przeanalizowanych - Analysed package nodes - s¹ to pakiety, które podlegaj¹ analizie w projekcie.
	\item Wierzcho³ki pakietów bibliotecznych - Library nodes - s¹ to pakiety, które wchodz¹ w sk³ad projektu ale nie podlegaj¹ analizie. Przyk³adem mo¿e byæ pakiet “java.lang”, który jest u¿ywany w projekcie, ale definicja jego klas nie znajduje siê w kodzie Ÿród³owym projektu.
	\end{itemize}
\item Wierzcho³ki katalogowe - Directory nodes - reprezentuj¹ kolejne elementy œcie¿ki danego pakietu. Mog¹ byæ rozumiane jako pakiety, które nie posiadaj¹ klas, lub katalogi w drzewie katalogów projektu. Przyk³adowym wierzcho³kiem katalogowym bêdzie “org.apache”, jeœli w projekcie znajduje siê pakiet “org.apache.commons.io”.
\end{itemize}

\paragraph{Krawêdzie}~\\
\begin{itemize}
\item Krawêdzie drzewa pakietów - Package tree edges - odzwierciedlaj¹ strukturê fizyczn¹ programu. Tego typu krawêdziami po³¹czone s¹ wierzcho³ki bêd¹ce w relacji “ojciec - syn” w drzewie pakietów. Przyk³adowo, pakiet “shimmer.service.impl” znajduje siê wewn¹trz pakietu “shimmer.service”, wiêc ich wierzcho³ki bêd¹ po³¹czone tak¹ krawêdzi¹. Równie¿ w tym przypadku sztuczny wierzcho³ek katalogowy “shimmer” po³¹czony bêdzie z wierzcho³kiem pakietowym “shimmer.service”.
\item Krawêdzie zale¿noœci miêdzy pakietami - Dependency edges - odzwierciedlaj¹ logiczne powi¹zania ³¹cz¹ce pakiety. Tego typu krawêdziami powi¹zane s¹ pakiety, których klasy korzystaj¹ z siebie nawzajem. Przyk³adowo, jeœli jakaœ klasa pakietu “shimmer.service” polega na innej klasie z pakietu “shimmer.service.impl”, pakiety po³¹czone bêd¹ tak¹ krawêdzi¹. Tego typu krawêdzie powinny równie¿ przechowywaæ wartoœæ mierz¹c¹ si³ê reprezentowanej zale¿noœci.
\end{itemize}

\subsection{Implementacja}\label{r:implementacja}

Implementuj¹c opisany w tym rozdziale model grafu stara³em siê zadbaæ o zachowanie dobrych praktyk projektowych oraz wydajny dostêp do poszczególnych wierzcho³ków. Ze wzglêdu na krokowy charakter analizy w Shimmer (ka¿dy modu³ wykonuje swoj¹ analizê jeden po drugim), dostêp do poszczególnych wierzcho³ków oraz krawêdzi powinien odbywaæ siê w czasie sta³ym. 

Graf posiada kolekcjê wierzcho³ków i krawêdzi oraz zbiór metod umo¿liwiaj¹cych wykonywanie podstawowych czynnoœci na swojej strukturze. Wierzcho³ki przechowywane s¹ w posortowanej hash-mapie (LinkedHashMap), gdzie kluczem jest pe³na nazwa pakietu identyfikuj¹ca wierzcho³ek. Kolekcja zbieraj¹ca krawêdzie jest posortowanym hash-zbiorem (LinkedHashSet). Dziêki temu dla obu kolekcji mo¿liwa jest iteracja w ustalonej kolejnoœci, a czas wykonania kluczowych operacji jest optymalny:

\begin{itemize}
\item wyszukiwanie wierzcho³ka po nazwie: O(1)
\item wyszukanie pakietu nadrzêdnego (ojca w drzewie pakietów) dla danego wierzcho³ka: O(1)
\item dodawanie wierzcho³ka oraz krawêdzi drzewa pakietów: O(1)
\item dodawanie krawêdzi zale¿noœci: O(1)
\end{itemize}

Wierzcho³ek grafu posiada swój typ i informacje na tema pakietu: nazwê, wartoœci wszystkich metryk i miar, oraz kolekcjê b³êdów. KrawêdŸ grafu zna swój typ, si³ê po³¹czenia, oraz oba ³¹czone wierzcho³ki.

Do konstruowania poszczególnych wierzcho³ków i krawêdzi wykorzysta³em wzorzec projektowy “fabryka” (Factory).

Taki sposób implementacji modelu jest ³atwo rozszerzalny i pozwala na proste rozbudowanie funkcjonalnoœci Shimmer w przysz³oœci, np. zwiêkszenie granularnoœci przez dodanie wierzcho³ków klasowych do modelu.

\section{Przebieg analizy}\label{r:analiza}

Analiza projektu rozpoczyna siê w momencie, gdy u¿ytkownik zdefiniuje œcie¿kê prowadz¹c¹ do plików skompilowanych projektu i u¿yje przycisku potwierdzenia. Przed uruchomieniem wszystkich mechanizmów, u¿ytkownik mo¿e równie¿ podaæ adres zdalnego repozytorium git lub œcie¿kê do sklonowanego repozytorium na dysku. 

\subsection{Analiza JDepend - tworzenie struktury programu}\label{r:jdepend}

Pierwszym krokiem analizy Shimmer jest uruchomienie analizatora JDepend na wskazanych plikach Ÿród³owych, b¹dŸ skompresowanych archiwach jar (analiza przez serwis JDepend mo¿e odbywaæ siê na obu rodzajach plików). Analizator JDepend bada klasy analizowanego projektu i wyniki swojego dzia³ania przedstawia w postaci posortowanej kolekcji danych dla poszczególnych pakietów. Obiekt przechowuj¹cy wyniki analizy dla konkretnego pakietu, posiada istotne cechy takie jak: nazwa pakietu, liczba klas konkretnych, liczba klas abstrakcyjnych, zbiór pakietów zale¿nych (afferent couplings oraz efferent couplings).

Otrzymuj¹c taki zestaw danych, Shimmer przegl¹da ka¿dy z wyników i buduje strukturê analizowanego programu:

\begin{itemize}
\item Dodaje do grafu projektu wszystkie wierzcho³ki reprezentuj¹ce przeanalizowane pakiety oraz biblioteki, np. “shimmer.service.impl”.
\item Dla ka¿dego z wierzcho³ków, znajduje jego rodzica w drzewie pakietów i ³¹czy go za pomoc¹ krawêdzi pakietowej, np. “shimmer.service.impl” zostaje po³¹czone z rodzicem “shimmer.service”
	\begin{itemize}
	\item Jeœli rodzic nie jest korzeniem drzewa i nie znajduje siê w grafie, oznacza to, ¿e nale¿y dodaæ do grafu wierzcho³ek katalogowy i po³¹czyæ go krawêdzi¹ pakietow¹, np. rodzicem pakietu “shimmer.service” jest “shimmer”, ale taki pakiet nie wystêpuje w projekcie, dlatego zostaje dodany jako katalog. Ten proces odbywa siê rekurencyjnie do momentu zbudowania pe³nej œcie¿ki.
	\end{itemize}
\item Dla ka¿dego wierzcho³ka dodaje do grafu krawêdzie zale¿noœci na podstawie zbioru pakietów zale¿nych. Modyfikacja wprowadzona przeze mnie do biblioteki JDepend pozwala okreœliæ, ile razy klasy zale¿nego pakietu importuj¹ klasy pakietu danego - ta informacja jest przechowywana w nowo utworzonej krawêdzi jako si³a zale¿noœci.
\end{itemize}

Po przeprowadzeniu tego kroku analizy, Shimmer posiada odwzorowanie badanego projektu w postaci grafu oraz zna podstawowe cechy jego wierzcho³ków (rozmiar, liczba klas abstrakcyjnych, pakiety zale¿ne itp.) i krawêdzi (si³a zale¿noœci, rodzaj powi¹zania). Dziêki tym informacjom Shimmer bêdzie w stanie przeprowadziæ wizualizacjê projektu w postaci grafu lub konstelacji.

\subsection{Analiza Findbugs - dodanie informacji o b³êdach}
Pierwsze próby u¿ycia biblioteki okaza³y siê bardzo niekorzystnie wp³ywaæ na czas wykonania g³ównej programu Shimmer i sk³oni³y mnie do szukania lepszego, bardziej wydajnego sposobu uruchamiania tego fragmentu analizy. Aby zwiêkszyæ wydajnoœæ narzêdzia, analiza wykonywana przez Findbugs uruchamiana jest w oddzielnym w¹tku, jako samodzielna instancja programu z odpowiednimi parametrami.

Parametry przekazywane analizatorowi Findbugs ró¿ni¹ siê w zale¿noœci od ustawieñ symulacji Shimmer:

\begin{itemize}
\item effort:[min|max] - ten parametr wy³¹cza analizy, które zwiêkszaj¹ precyzjê, ale zu¿ywaj¹ du¿e iloœci pamiêci - to ustawienie w trybie “min” pozwala przyspieszyæ dzia³anie programu kosztem iloœci wykrytych usterek
\item relaxed - raportowanie b³êdów nie opiera siê na sztywno zdefiniowanych heurystykach - gdy zale¿y nam na mniejszej iloœci detekcji false-positive, kosztem szybkoœci dzia³ania, Shimmer powinien zrezygnowaæ z tego parametru
\item nested:false - ustawienie zapobiega poszukiwaniu zagnie¿d¿onych archiwów zip i jar wewn¹trz wejœciowego katalogu projektu - ten parametr nie ulega zmianom
\item xml - tworzy plik wynikowy w postaci tekstu xml - ten parametr równie¿ pozostaje sta³y
\end{itemize}

Generowany przez Findbugs plik xml jest tworzony w katalogu tymczasowym, nastêpnie analizowany przez parser DOM. Report zawiera miêdzy innymi elementy reprezentuj¹ce wykryte usterki (BugInstance) oraz statystyki konkretnych pakietów (PackageStats) i klas (ClassStats). Shimmer parsuj¹c raport tworzy obiekty b³êdów i dodaje je do odpowiednich pakietów z grafu. Ka¿dy b³¹d posiada pe³n¹ nazwê klasy, w której zosta³ wykryty i na jej podstawie odnajdywany jest pakiet w grafie projektu. Ponadto obiekt reprezentuj¹cy b³¹d posiada atrybuty nadane przez Findbugs:

\begin{itemize}
\item kategoria b³êdu - etykieta kategoryzuj¹ca rozpoznan¹ usterkê np. “Bad practice”
\item typ b³êdu - identyfikator okreœlaj¹cy konkretny typ b³êdu rozpoznawanego przez Findbugs - na jego podstawie mo¿liwe jest pozyskanie dok³adniejszego opisu usterki w katalogu autorów Findbugs
\item ranga b³êdu - wartoœæ w przedziale 1-20 stwierdza poziom zagro¿enia usterki, gdzie 1 oznacza b³êdy najpowa¿niejsze, a 20 najdrobniejsze usterki
\item priorytet - ustalony przez Findbugs na podstawie rangi dla ³atwiejszego grupowania b³êdów: 
	\begin{itemize}
	\item scariest (ranga 1-4), 
	\item scary (ranga 5-9), 
	\item troubling (ranga 10-14), 
	\item of concern (ranga 15-20)
	\end{itemize}
\item pewnoœæ (confidence) - wartoœæ w przedziale 1-5 stwierdza stopieñ przekonania o poprawnoœci raportu, gdzie 1 oznacza b³¹d, którego pewnoœæ jest najmniejsza
\end{itemize}

Dodatkowe informacje, które Findbugs umieszcza w elementach statystyk pakietowych to przede wszystkim ³¹czna liczba usterek ka¿dego z 4 priorytetów oraz rozmiar pakietu na podstawie analizy NCSS dla klas.

Informacje, które nie s¹ zawarte w pliku wynikowym, to s³owna nazwa typu b³êdu i tekstowy opis usterki - jedyn¹ informacj¹ o typie b³êdu jest jego skrótowy identyfikator. Normaln¹ procedur¹ podczas korzystania z Findbugs jest u¿ywanie dostarczonego œrodowiska GUI, gdzie za³¹czone s¹ treœci opisów poszczególnych b³êdów, b¹dŸ pos³ugiwanie siê indeksem rozpoznawanych b³êdów, zamieszczonym na stronie projektu - wyszukuj¹c opisy wed³ug skrótowego identyfikatora. Aby poprawiæ jakoœæ i wygodê korzystania z Shimmer, przygotowa³em prosty parser aktualnego indeksu b³êdów i wczyta³em zawarte w nim dane do s³ownika. Dziêki temu znaj¹c identyfikator typu b³êdu, na etapie wizualizacji mo¿liwe jest wyœwietlenie pe³nego tekstowego raportu o b³êdach, ³¹cznie z tekstowymi opisami usterek.

Analiza Findbugs nie jest niezbêdnym krokiem wymaganym do wizualizacji projektu, dlatego ze wzglêdu na czasoch³onnoœæ tej czynnoœci mo¿liwe jest jej pominiêcie na ¿yczenie u¿ytkownika. Wyniki pozyskiwane w tym kroku pozwalaj¹ narzêdziu Shimmer wskazaæ najbardziej podejrzane pakiety i przedstawiæ czytelny raport usterek dla ka¿dego z nich.

\subsection{Analiza jGit - dodanie informacji historycznych projektu}
Kolejnym krokiem analizy jest wydobycie metryk historycznych z repozytorium projektu. Aby by³o to mo¿liwe, repozytorium badanego projektu powinno znaleŸæ siê na lokalnym dysku dostêpnym dla œrodowiska aplikacji Shimmer (jGit nie pozwala na ³atwe pozyskanie wymaganych informacji pos³uguj¹c siê jedynie zdalnym repozytorium). W zwi¹zku z tym, jeœli u¿ytkownik poda³ adres internetowy repozytorium zdalnego, jest ono klonowane przez bibliotekê jGit. Czasoch³onnoœæ tej operacji sk³oni³a mnie do umo¿liwienia rêcznego sklonowania repozytorium zdalnego przed rozpoczêciem analizy i przekazania analizatorowi œcie¿ki do gotowego repozytorium lokalnego.

Maj¹c dostêp do repozytorium lokalnego, analizator przegl¹da wszystkie pliki podlegaj¹ce systemowi kontroli wersji i stara siê znaleŸæ w grafie projektu odpowiadaj¹ce im pakiety. Dopasowanie odbywa siê na zasadzie analizy œcie¿ki i nazwy pliku w repozytorium. Przyk³adowo plik znajduj¹cy siê pod œcie¿k¹: \verb+src\main\java\shimmer\service\GraphService.java+  zostanie dopasowany do pakietu “shimmer.service”. Jeœli dla danego pliku dopasowanie istnieje, narzêdzie jGit przegl¹da kontrybucje zmieniaj¹ce dany plik (liczba kontrybucji jest ograniczona do 500 wstecz) i dla danego pakietu w grafie aktualizuje liczbê wszystkich kontrybucji, datê ostatniej zmiany oraz liczbê autorów.

Analiza jGit nie jest obowi¹zkowym krokiem w procesie badania wybranego projektu, dlatego mo¿e zostaæ pominiêta na ¿yczenie u¿ytkownika. Informacje pozyskane w tym kroku wzbogacaj¹ wiedzê na temat historii zmian projektu i pozwalaj¹ na wygenerowanie mapy termicznej metryk historycznych w widoku konstelacji.

%TODO
\paragraph{TODO:}
\textit{Tutaj potrzebujê konkretnego cytowania odnoœnie metryk projektowych / pakietowych.}

\subsection{Wyliczenie wartoœci metryk}
W tym kroku, na podstawie stworzonego grafu projektu, wyliczane s¹ wartoœci wszystkich metryk dostêpnych w programie, które wymagaj¹ dodatkowych kalkulacji. Niektóre metryki s¹ pozyskiwane bezpoœrednio w poprzednich krokach analizy i nie wymagaj¹ obliczeñ.

\paragraph{Number of Classes and Interfaces / Class count (Cc)}~\\

Liczba klas konkretnych, klas abstrakcyjnych, oraz interfejsów w pakiecie jest miar¹ rozszerzalnoœci pakietu. Wartoœæ tej metryki dostarcza analizator JDepend.

\paragraph{Concrete Classes}~\\

Liczba klas konkretnych w pakiecie na podstawie analizy JDepend. Na podstawie tej metryki jesteœmy w stanie okreœliæ jak¹ czêœæ pakietu stanowi implementacja / kod wykonywany.

\paragraph{Abstract Classes (Ac)}~\\

Liczba klas abstrakcyjnych i interfejsów w pakiecie wed³ug analizatora JDepend. Wartoœæ tej metryki pozwala nam stwierdziæ jak¹ czêœæ pakietu stanowi¹ abstrakcje projektowe.  

\paragraph{Total Size (Ts)}~\\

Rozmiar ca³kowity. Suma rozmiarów wszystkich klas z pakietu. Rozmiar pojedynczej klasy liczony jest przez analizator Findbugs. W ka¿dej klasie zliczane s¹ istotne elementy wp³ywaj¹ce na jej rozmiar - pola, metody, linie instrukcji. Pomijane s¹ fragmenty, które nie wp³ywaj¹ na si³ê wyrazu, np. komentarze i bia³e znaki (NCSS - “Non Commenting Source Statements”). Suma rozmiarów zliczana jest podczas przetwarzania wyników analizy dla klas wewn¹trz pakietów (ClassStats). Dziêki tej metryce, w odró¿nieniu od liczby klas, mo¿emy dok³adniej zobrazowaæ faktyczny rozmiar pakietu.

\paragraph{Largest Class Size}~\\

Rozmiar najwiêkszej klasy z pakietu. Analizator Findbugs przetwarzaj¹c wyniki analizy dla poszczególnych klas w danym pakiecie (ClassStats) znajduje rozmiar najwiêkszej z klas. Ta metryka pozwala nam w ³atwy sposób wskazaæ pakiety, w których znajduj¹ siê klasy o zbyt du¿ej z³o¿onoœci - byæ mo¿e wymagaj¹ce refaktoryzacji.

\paragraph{Average Size (As)}~\\

Œredni rozmiar klas. Liczony jako œrednia arytmetyczna rozmiaru klas z dzieleniem ca³kowitym. Metryka pozwala na ogólne zobrazowanie rozmiaru pakietu ze wzglêdu na rozmiar klas, a nie iloœæ.

\begin{equation}
As = Ts / Cc
\end{equation}

\paragraph{Afferent Couplings (Ca)}~\\

Powi¹zania aferentne - liczba innych pakietów, które polegaj¹ na klasach z pakietu danego. Metryka wyra¿a odpowiedzialnoœæ (responsibility) danego pakietu. Analizator JDepend podaje t¹ wartoœæ w sposób niestandardowy - w literaturze czêœciej spotykan¹ miar¹ jest liczba klas z obcych pakietów, które polegaj¹ na klasach z pakietu danego. Modyfikacja, któr¹ wprowadzi³em do analizatora JDepend pozwala na pozyskanie dodatkowej informacji - ile klas z wybranego pakietu polega na klasach z pakietu danego. Dziêki tej modyfikacji Shimmer zna nie tylko liczbê powi¹zañ z innymi pakietami, ale te¿ ich si³ê.

\paragraph{Efferent Couplings (Ce)}~\\

Powi¹zania eferentne - liczba innych
 pakietów, na których polegaj¹ klasy z pakietu danego. Metryka wyra¿a zale¿noœæ (dependency) danego pakietu. Podobnie, jak w przypadku Afferent Couplings, wartoœæ liczona jest przez analizator JDepend przy uwzglêdnieniu si³y zale¿noœci - liczby klas zale¿nych. W tym obszarze równie¿ konieczna by³a modyfikacja kodu biblioteki.

\paragraph{Abstractness (A)}~\\

Abstrakcyjnoœæ - stosunek liczby interfejsów i klas abstrakcyjnych do liczby wszystkich klas z danego pakietu. Metryka przyjmuje wartoœci z przedzia³u od 0 do 1, gdzie 0 oznacza pakiet w pe³ni konkretny, a 1 pakiet ca³kowicie abstrakcyjny.

\begin{equation}
A = Ac / Cc
\end{equation}

\paragraph{Instability (I)}~\\

Niestabilnoœæ - stosunek liczby powi¹zañ eferentnych do liczby wszystkich powi¹zañ pakietu. Metryka wyra¿a podatnoœæ pakietu na zmiany. Przyjmuje wartoœci z przedzia³u od 0 do 1, gdzie 0 oznacza pakiet w pe³ni stabilny (nie zmienia siê w wyniku zmian innych pakietów), a 1 oznacza pakiet ca³kowicie niestabilny (zale¿ny od pozosta³ych).

\begin{equation}
I = Ce / (Ce + Ca)
\end{equation}

\paragraph{Distance from the Main Sequence (D)}~\\

%TODO
Odleg³oœæ od idealnej linii równania $A + I = 1$. Zgodnie z \cite{bib_metr} pakiety powinny byæ abstrakcyjne lub niestabilne. Pakiety osadzone na linii tego równania zachowuj¹ odpowiedni balans pomiêdzy abstrakcj¹ a stabilnoœci¹. Przyjmuje wartoœci z przedzia³u od 0 do 1, gdzie 0 oznacza pakiet zgodny z g³ównym za³o¿eniem, a 1 oznacza pakiet mo¿liwie najdalej oddalony od idealnego równania.

\paragraph{Abstract or Instable (AoI)}~\\

Metryka wyra¿a balans pakietu pomiêdzy abstrakcj¹, a niestabilnoœci¹ - stwierdza, czy w danym pakiecie przewa¿a abstrakcyjnoœæ, czy niestabilnoœæ - zgodnie z za³o¿eniami o odleg³oœci od idealnej sekwencji. Ta miara pozwala podzieliæ pakiety ze wzglêdu na ich charakter. Przyjmuje wartoœci od -1 do 1, gdzie -1 oznacza pakiet, w którym w pe³ni przewa¿a niestabilnoœæ, a 1 oznacza pakiet zdominowany przez abstrakcjê.

\begin{equation}
AoI = A - I
\end{equation}

\paragraph{Total Bugs}~\\

Liczba usterek, które zosta³y wykryte przez analizator Findbugs wewn¹trz pakietu. Jest to metryka za pomoc¹ której w czytelny sposób mo¿na wizualizowaæ jakoœæ kodu.

\paragraph{Authors Count}~\\

Liczba autorów, którzy wprowadzali zmiany do danego pakietu na podstawie historii z systemu kontroli wersji. Pakiety, nad którymi pracowa³a du¿a liczba autorów mog¹ zawieraæ g³ówn¹ funkcjonalnoœæ projektu.

\paragraph{Total Commits}~\\

Liczba wszystkich zmian w systemie kontroli wersji, które dotyczy³y danego pakietu. Metryka wskazuje na z³o¿onoœæ danego pakietu. Kod, który posiada wiele kontrybucji prawdopodobnie:

\begin{itemize}
\item dotyczy jednej z g³ównych funkcjonalnoœci projektu - jest stale rozwijany
\item jest podatny na zmiany / usterki - wymaga czêstej refaktoryzacji
\end{itemize}

\paragraph{Last Commit}~\\

Data ostatniej zmiany w systemie kontroli wersji. Dla u¿ytkownika mo¿e wskazywaæ hermetyczny charakter pakietu - kod, który od d³ugiego czasu nie by³ zmieniany prawdopodobnie:

\begin{itemize}
\item jest solidny i nie wymaga poprawek,
\item nie dotyczy ¿adnej g³ównej, rozwijanej w projekcie funkcjonalnoœci,
\item jest kodem który trudno zmieniæ
\end{itemize}

\subsection{Serializacja}
Przeanalizowane dane serializowane s¹ do formatu JSON, który jest wymagany przez biblioteki wizualizacji grafów - tablice wierzcho³ków i krawêdzi. 

Podczas serializacji wierzcho³ków i krawêdzi konieczne jest prze³o¿enie wartoœci metryk na odpowiednie atrybuty wizualizowanych obiektów. W zale¿noœci od ustawieñ u¿ytkownika oraz wartoœci wybranych metryk ustalane s¹:

\begin{itemize}
\item kolor wierzcho³ków
\item rozmiar wierzcho³ków
\item temperatura wierzcho³ków
\item d³ugoœæ krawêdzi
\end{itemize}

Zamiana wartoœci metryk na parametry wizualizacyjne odbywa siê oddzielnie dla ka¿dej metryki i parametru, a ustawienie odpowiednich proporcji zosta³o dobrane eksperymentalnie.

Na tym etapie brane pod uwagê s¹ równie¿ ustawienia kalibracyjne wizualizacji. Podczas pracy z projektami o ró¿nych parametrach u¿ytkownik mo¿e mieæ potrzebê przedefiniowania domyœlnych interpretacji wartoœci - przyk³adowo, jeœli nowy projekt posiada niewiele zmian w systemie kontroli wersji, chcemy aby wizualizacja mapy termicznej by³a bardziej wra¿liwa na liczbê zmian w danym pakiecie (pakiety z pozornie niewielk¹ iloœci¹ zmian powinny byæ uznawana za “gor¹ce”).

Obiekty powsta³e w wyniku serializacji (krawêdzie i wierzcho³ki w postaci JSON) stanowi¹ dane wejœciowymi dla narzêdzi wizualizacyjnych, ale zawieraj¹ równie¿ dodatkowe metadane, z których korzysta widok aplikacji Shimmer: informacje o wartoœciach wszystkich metryk, identyfikatory wykrytych usterek, kategorie wierzcho³ków.

\section{Wizualizacja}\label{r:wizualizacja}
\subsection{Podstawa wizualizacji - graf}

%TODO
\paragraph{TODO:}
\textit{Zacytujê / dodam referencjê odnoœnie VisJS}

Podstaw¹ do wizualizacji w Shimmering Constellation jest wizualizacja grafowa. Biblioteka, która odpowiada za wizualizowanie grafu to VisJs. Narzêdzie pozwala na dynamiczn¹ wizualizacjê grafu w oparciu o model dystrybucji cz¹steczek Barnes-Hut.

VisJs pobiera wynik analizy w postaci list wierzcho³ków i krawêdzi w formacie JSON i wyœwietla graf projektu z odpowiednimi parametrami. Prezentowana wizualizacja jest równowa¿ona w czasie rzeczywistym i pozwala u¿ytkownikowi na dowolne manipulowanie grafem - skalowanie, przesuwanie, przemieszczanie wierzcho³ków.

\subsection{Wizualizacja zaawansowana - mapa termiczna}

%TODO
\paragraph{TODO:}
\textit{Zacytujê / dodam referencjê odnoœnie HeatmapsJS}

Dope³niaj¹cym elementem wizualizacji jest mapa termiczna, która wyœwietlana jest w tle wizualizowanego grafu. Generowaniem mapy termicznej zajmuje siê biblioteka Heatmap.js. Mapa termiczna oddaje temperaturê poszczególnych wierzcho³ków.

Ze wzglêdu na dynamiczny charakter prezentacji grafu, mapa termiczna jest odœwie¿ana z ustalon¹ czêstotliwoœci¹ za ka¿dym razem, gdy graf zmienia swoje po³o¿enie, jest równowa¿ony, lub skalowany. Dziêki temu mapa termiczna adaptuje zmiany, którym ulega graf i jest w stanie dostosowaæ siê do jego dynamicznego charakteru.

Ze wzglêdu na z³o¿onoœæ obliczeniow¹ odœwie¿ania mapy termicznej, u¿ytkownik mo¿e tymczasowo zatrzymaæ jej generowanie. Ta funkcjonalnoœæ mo¿e byæ przydatna przy pracy z du¿ymi projektami, kiedy u¿ytkownik chce zmodyfikowaæ u³o¿enie grafu - tymczasowe zatrzymanie mapy termicznej pozwoli na szybkie wykonanie zmian w grafie i uruchomienie mapy termicznej ju¿ po zrównowa¿eniu grafu, bez koniecznoœci oczekiwania na aktualizacjê mapy w ka¿dym kroku. 

\subsection{Sugerowane sposoby wizualizacji metryk}

Narzêdzie Shimmering Constellations pozwala u¿ytkownikowi na samodzielny wybór sposobu obrazowania poszczególnych metryk. Jenak niektóre z metryk, ze wzglêdu na swój charakter, w oczywisty sposób s¹ lepiej wyra¿ane za pomoc¹ konkretnych œrodków:

\begin{description}
\item[Rozmiar wierzcho³ka (iloœæ)] - pos³uguj¹c siê tym parametrem, mo¿emy w naturalny sposób odzwierciedlaæ iloœciow¹ charakterystykê kodu. U¿ytkownik jest w stanie ³atwo skojarzyæ wielkoœæ wierzcho³ka z liczb¹ klas w pakiecie lub ca³kowit¹ liczb¹ linii kodu.
\item[Kolor wierzcho³ka (jakoœæ)] - pozwala dokonaæ jakoœciowej analizy kodu, zw³aszcza zestawiaj¹c kolory ze skali od czerwonego do zielonego. Osoba ogl¹daj¹ca wizualizacjê mo¿e rozpoznaæ czerwone wierzcho³ki jako pakiety niskiej jakoœci, a zielone wysokiej. Oprócz jakoœci, w narzêdziu Shimmer kolor mo¿e równie¿ oddawaæ charakterystykê badanego elementu. Przyk³adowo wierzcho³ki biblioteczne maj¹ zawsze kolor szary, a wierzcho³ki katalogowe kolor niebieski.
\item[Temperatura wierzcho³ka (aktywnoœæ)] - stanowi pomocniczy sposób wyrazu i mo¿e s³u¿yæ do obrazowania cech szczególnych kodu, które podlegaj¹ stopniowaniu. Dobrym zastosowaniem tego parametru jest zobrazowanie czêstoœci zmian danego elementu - u¿ytkownik mo¿e rozpoznaæ wierzcho³ki gor¹ce jako “aktywne”, a ch³odne jako stabilne, niezmienne. 
\item[D³ugoœæ krawêdzi (zale¿noœæ)] - pozwala w ³atwy sposób zobrazowaæ si³ê powi¹zania miêdzy poszczególnymi elementami. Wierzcho³ki znajduj¹ce siê blisko siebie w znormalizowanym grafie, s¹ od siebie silnie zale¿ne, a wierzcho³ki oddalone nie maj¹ mocnych powi¹zañ.
\end{description}

Sugerowane sposoby wizualizacji metryk przedstawiono w tabeli \ref{t_sposoby}

\begin{table}[t]
\centering
\label{t_sposoby}
	\begin{tabular}{rl}
	\hline 
	Metryka & Sugerowany sposób obrazowania\\
	\hline
	Class count & rozmiar \\
	Concrete Classes & rozmiar \\
	Abstract Classes & rozmiar \\
	Total Size & rozmiar \\
	Largest Class Size & kolor \\
	Average Size & rozmiar lub kolor \\
	Afferent / Efferent Couplings & d³ugoœæ krawêdzi \\
	Abstractness & kolor lub temperatura \\
	Instability & kolor lub temperatura \\
	Abstract or Instable & kolor \\
	Distance from the Main Sequence & kolor \\
	Total Bugs & kolor \\
	Authors Count & temperatura \\
	Last Commit & temperatura \\
	Total Commits & temperatura \\
	\hline
	\end{tabular} 
\caption{Zestawienie sugerowanych sposobów wizualizacji poszczególnych metryk}
\end{table}

\section{Funkcjonalnoœæ}

\subsection{Dwie metody wizualizacji}

Shimmer udostêpnia dwie metody wizualizacji projektów: graf oraz konstelacja.

Wizualizacja grafowa jest podstawow¹ metod¹ pozwalaj¹c¹ w jawny sposób przedstawiæ powi¹zania pomiêdzy pakietami lub kompletne drzewo zagnie¿d¿enia pakietów. Przyjêty model grafu projektu jest w sposób bezpoœredni odwzorowywany w wizualizacji.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img1.png}
\caption{Projekt jUnit wizualizowany w postaci grafu}
\end{figure}

Wizualizacja konstelacyjna opiera siê na za³o¿eniach przestawionych w pracy \cite{bib_cons}. Podstaw¹ do jej stworzenia jest graf projektu, jednak krawêdzie s¹ niewidoczne, a zale¿noœci miêdzy pakietami s¹ obrazowane przez odleg³oœci miêdzy wierzcho³kami. W tym widoku szczególne zastosowanie odnajduje mapa termiczna, która wzbogaca si³ê jego wyrazu o dodatkowy parametr - temperaturê wierzcho³ków.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img2.png}
\caption{Projekt jUnit wizualizowany w postaci konstelacji}
\end{figure}

Metodê wizualizacji mo¿na zmieniæ w trakcie dzia³ania programu, bez koniecznoœci analizowania projektu na nowo.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{img3.png}
\caption{Panel zmiany metody wizualizacji}
\end{figure}

\subsection{Czytelny raport usterek}

Po wybraniu pakietu, Shimmer wyœwietla czytelny raport usterek wykrytych przez analizator Findbugs. Szczegó³owe opisy usterek pochodz¹ z oficjalnej dokumentacji Findbugs.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img4.png}
\caption{Fragment raportu usterek dla pakietu org.junit.rules z projektu JUnit}
\end{figure}

\subsection{Dynamicznie modyfikowane parametry analizy}

Shimmer pozwala u¿ytkownikowi decydowaæ o tym, jakie metryki powinny byæ wizualizowane za pomoc¹ ka¿dego z dostêpnych parametrów (d³ugoœæ krawêdzi, kolor, rozmiar i temperatura wierzcho³ków). Ponadto pozwala na wykluczenie szczególnych typów wierzcho³ków i krawêdzi z wizualizacji - przyk³adowo u¿ytkownik mo¿e zdecydowaæ o ukryciu pakietów bibliotecznych, a zdecydowaæ siê na wyœwietlenie wierzcho³ków symbolizuj¹cych katalogi pakietów.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img5.png}
\caption{Panel ustawieñ symulacji}
\end{figure}

Odpowiednio dobrane ustawienia mog¹ zale¿eæ od celu u¿ytkownika - widok grafowy z krawêdziami drzewa pakietów i wierzcho³kami katalogowymi mo¿e w œcis³y sposób oddaæ fizyczn¹ architekturê projektu. Natomiast widok konstelacyjny bez pakietów bibliotecznych i katalogów, z krawêdziami zale¿noœci o wa¿onych d³ugoœciach pozwoli skupiæ siê na jakoœci kodu zawartego w projekcie.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{img6.png}
\caption{Wybór metryki dla temperatury wierzcho³ka}
\end{figure}

Manipulacja ustawieniami odbywa siê w sposób dynamiczny, a wprowadzanie zmian do wizualizacji nie wymaga ponownej analizy projektu.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img7.png}
\caption{Krawêdzi oznaczaj¹ zale¿noœci eferentne pakietów, a ich d³ugoœæ wskazuje na si³ê zale¿noœci - liczbê klas zale¿nych. Wielkoœæ wierzcho³ków oznacza liczbê klas w pakiecie, a kolor liczbê wykrytych usterek.}
\end{figure}

\subsection{Kalibracja metryk i wizualizacji}

Przy pracy z projektami o ró¿nych charakterystykach konieczne mo¿e byæ naniesienie pewnych poprawek interpretacyjnych na mechanizm obrazowania metryk. Przyk³adowo w projekcie uruchamianym jedynie testowo / lokalnie, mo¿emy zdecydowaæ siê na tolerowanie kilku usterek zg³oszonych przez Findbugs - wtedy u¿ytkownik mo¿e zwiêkszyæ próg tolerancji liczby b³êdów, tak aby kolor wierzcho³ków (jeœli u¿ywamy go do obrazowania liczby b³êdów) nie by³ zbyt jednolity. Dla przeciwnego przyk³adu - w projekcie, który powinien cechowaæ siê du¿¹ niezawodnoœci¹, u¿ytkownik mo¿e zmniejszyæ próg tolerancji b³êdów, aby oznaczyæ wszystkie podejrzane wierzcho³ki z wiêksz¹ dok³adnoœci¹.

Podobnym ustawieniom mo¿e podlegaæ jeszcze szereg parametrów kalibracyjnych:

\begin{itemize}
\item rozmiar wierzcho³ka
\item wiek zmian
\item liczba zmian w systemie kontroli wersji
\item liczba klas w pakiecie
\item rozmiar klasy
\end{itemize}

Zmiany tych parametrów nie wymagaj¹ ponownej analizy.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img8.png}
\caption{Panel kalibracji metryk}
\end{figure}

Dynamicznym modyfikacjom mog¹ podlegaæ równie¿ ustawienia aparatu fizycznego symulacji. Odpowiednie ustawienie takich parametrów, jak sta³a grawitacyjna lub domyœlna d³ugoœæ krawêdzi (w u¿ywanym modelu fizycznym reprezentowanych jako sprê¿yny) mo¿e byæ ró¿ne dla projektów o odmiennych parametrach i nieznacznie odbiegaæ od ustawieñ domyœlnych. Zaawansowany u¿ytkownik bêdzie w stanie w pe³ni kontrolowaæ symulacjê fizyczn¹ wedle potrzeb zmieniaj¹c jej charakter na bardziej dynamiczny, statyczny, rozleg³y, skupiony itp.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img9.png}
\caption{Panel ustawieñ modelu fizycznego}
\end{figure}

\subsection{Mo¿liwoœæ zapisu i odczytu wyników analizy}

Czasoch³onnoœæ procesu analizy sk³oni³a mnie do umo¿liwienia u¿ytkownikowi zapisania wyników na dysku i odtworzenia wizualizacji bez koniecznoœci wykonywania obliczeñ. W pliku tekstowym, oprócz elementów grafu w postaci JSON zapisywane s¹ równie¿ ustawienia symulacji.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{img10.png}
\caption{Panel zapisu  / odczytu gotowego projektu}
\end{figure}

\subsection{Przystêpny interfejs u¿ytkownika}

Interfejs aplikacji zosta³ stworzony z myœl¹ o intuicyjnoœci i wygodzie u¿ytkownika. Do komunikacji z u¿ytkownikiem wykorzystano dynamiczne komponenty oparte o biblioteki Bootstrap i PrimeFaces. Ponadto zadbano o wszelkie udogodnienia wp³ywaj¹ce na jakoœæ interfejsu - pasek postêpu obliczeñ, animacje komponentów, wskaŸnik równowa¿enia grafu, gradacjê kolorystyczn¹ w odwzorowaniu wartoœci metryk.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img11.png}
\caption{Ekran g³ówny programu Shimmering Constelletions}
\end{figure}

\subsection{Mo¿liwoœæ przeprowadzenia analizy czêœciowej}

Aby skróciæ czas oczekiwania na wyniki obliczeñ, u¿ytkownik mo¿e zdecydowaæ o pominiêciu niektórych etapów analizy. Analiza Findbugs (poszukiwanie usterek) oraz JGit (wydobywanie metryk historycznych z repozytorium) nie s¹ niezbêdne do przeprowadzenia wizualizacji - w rezultacie niektóre wyniki obliczeñ nie bêd¹ dostêpne przy symulacji. Ta funkcjonalnoœæ jest przydatna, jeœli znany jest konkretny cel wizualizacji i wiemy, jakich informacji o projekcie nie chcemy obrazowaæ - mo¿emy wtedy zrezygnowaæ z czasoch³onnych obliczeñ.  Ponadto u¿ytkownik mo¿e zmniejszyæ priorytet analizatora Findbugs - poskutkuje to szybszym dzia³aniem, ale zg³oszeniem wiêkszej iloœci b³êdów false-positive.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img12.png}
\caption{Panel umo¿liwiaj¹cy pominiêcie wybranych modu³ów}
\end{figure}

% ------------------------------------------------------------------------------
% ROZDZIA£ BADANIA
\chapter{Badanie, wyniki oraz wnioski}\label{r:badanie}
Aby wykazaæ dzia³anie stworzonego oprogramowania, rozs¹dnym krokiem jest prezentacja jego przyk³adowego u¿ycia, lub zebranie opinii u¿ytkowników.

W tym rozdziale przedstawiono przyk³adowe zastosowanie programu Shimmering Constellations do analizy popularnych projektów. Ponadto, w celu weryfikacji nowych metod wizualizacyjnych przeprowadzono ankietê wœród studentów kierunku Informatyka. Ostatecznie zebrano wnioski p³yn¹ce z przyk³adów wizualizacji i przeprowadzonego badania.

\section{Przyk³ady wizualizacji}

%TODO
\paragraph{TODO:}
\textit{Umieszczê 3 przyk³adowe wizualizacje znanych projektów z krótkimi opisami}

\section{Ankieta}

Aby poznaæ opiniê u¿ytkowników na temat konstelacyjnej metody wizualizacji i porównaæ j¹ z popularn¹ wizualizacj¹ grafow¹, przeprowadzono ankietê wœród studentów Uniwersytetu Warszawskiego. W badaniu wziê³a udzia³ grupa 100 uczestników kursu In¿ynieria Oprogramowania, której zaprezentowano oprogramowanie Shimmer. W konfiguracji testowej, oprogramowanie umo¿liwia³o wyœwietlenie projektu jUnit za pomoc¹ grafu oraz konstelacji. Nastêpnie, po obejrzeniu obu wizualizacji, uczestnicy udzielali odpowiedzi na nastêpuj¹ce pytania:

\begin{enumerate}
\item Któr¹ metodê wizualizacji preferujesz?
\item Która metoda wizualizacji wydaje Ci siê czytelniejsza?
\item Która metoda wizualizacji wydaje Ci siê bardziej estetyczna?
\item Która metoda pozwala szybciej wykryæ podejrzane elementy projektu?
\item Która z metod lepiej demonstruje architekturê projektu?
\item Bêd¹c na pozycji osoby decyzyjnej (np. Project Director decyduj¹cy o finansowaniu projekt), której metody wola³byœ u¿ywaæ do szybkiej oceny sytuacji w projekcie?
\item Bêd¹c na miejscu in¿yniera pracuj¹cego nad projektem (np. cz³onek zespo³u programistów, który refaktoryzuje kod), któr¹ z metod wybra³byœ do codziennej pracy?
\end{enumerate}

 Dobór pytañ testowych mia³ w zamyœle wykrycie wyraŸnych ró¿nic w charakterze i zastosowaniach metody konstelacyjnej i klasycznej grafowej.

%TODO
\paragraph{TODO:}
\textit{Umieszczê wyniki ankiety w tabeli lub na wykresie}

\section{Wnioski}

%TODO
\paragraph{TODO:}
\textit{Krótko podsumujê wnioski wyci¹gniête z ankiety}

% ------------------------------------------------------------------------------
% ROZDZIA£ PODSUOWANIE
\chapter{Podsumowanie pracy}\label{r:podsumowanie}

W pracy opisano narzêdzie do wizualizacji projektów informatycznych, którego kod udostêpniono na zasadach Open Source. Program Shimmering Constelletion ³¹czy w sobie techniki wizualizacji konstelacyjnej oraz grafowej ze zintegrowan¹ map¹ termiczn¹. Wizualizacja kodu w programie pozwala nie tylko w sposób czytelny zobrazowaæ dany projekt, ale uwzglêdnia te¿ zachodz¹ce w nim zmiany i umo¿liwia analizê jakoœci. Skutecznoœæ wykorzystanych metod w poszczególnych obszarach zastosowañ potwierdzi³y przeprowadzone badania preferencji u¿ytkowników.

\section{Perspektywy dalszego rozwoju oprogramowania}

Oprogramowanie Shimmering Constellations powsta³o z myœl¹ o mo¿liwoœci przysz³ego rozbudowywania jego funkcjonalnoœci. Architektura i implementacja (patrz rozdzia³ \ref{r:architektura} oraz \ref{r:implementacja}) aplikacji by³y tworzone zgodnie ze sztuk¹ pragmatycznego programowania, aby umo¿liwiæ dalszy rozwój systemu i zapewniæ jego wysok¹ skalowalnoœæ. Obecnie przewidziano nastêpuj¹ce mo¿liwoœci rozwoju narzêdzia:

\paragraph{Zwiêkszenie granularnoœci:} Korzystnym krokiem w rozwoju systemu by³oby zwiêkszenie granularnoœci wizualizacji. Obecnie kod obrazowany przez Shimmer przedstawiany jest na poziomie pakietów i na tym stopniu liczona jest wiêkszoœæ dostarczanych metryk. Rozbudowanie aplikacji o analizê na poziomie poszczególnych klas wymaga³oby jedynie niewielkich zmian w analizatorze JDepend (rozdzia³ \ref{r:jdepend}) i modelu projektu (rozdzia³ \ref{r:model}). Biblioteka wizualizacyjna visJs pozwala na automatyczn¹ obs³ugê klastrowania wierzcho³ków - dziêki temu wierzcho³ki reprezentuj¹ce klasy mog³yby ³¹czyæ siê w wierzcho³ki klastrowe reprezentuj¹ce poszczególne pakiety (stan obecny). Takie rozbudowanie zwiêkszy³oby dok³adnoœæ narzêdzie Shimmer.

\paragraph{Uruchomienie aplikacji www:} Dobrym wykorzystaniem narzêdzia Shimmer mog³oby by byæ uruchomienie go w postaci us³ugi online na serwerach uczelni w celach naukowych. Uczestnicy kursu In¿ynieria Oprogramowania mogliby przy u¿yciu opisanego programu analizowaæ wybrane projekty informatyczne, a wyniki analiz zbierane w bazie danych pozwoli³yby badaæ studentom i pracownikom instytutu projekty Open Source. Taka modyfikacja, dziêki architekturze opartej na aplikacji www (patrz rozdzia³ \ref{r:architektura}), wymaga³aby jedynie integracji z wybran¹ baz¹ danych. 

\paragraph{Dodanie nowych metryk i modu³ów:} Oczywistym rozszerzeniem dla aplikacji Shimmer jest implementacja nowych metryk i modu³ów analizuj¹cych kod projektu. Chc¹c wzbogaciæ program o mo¿liwoœæ wizualizacji dodatkowej metryki, nale¿y dodaæ odpowiedni analizator do g³ównego procesu programu (rozdzia³ \ref{r:analiza}), rozbudowaæ model o nowe w³aœciwoœci (rozdzia³ \ref{r:model}) i zadbaæ o odpowiednie obrazowanie nowej cechy (rozdzia³ \ref{r:wizualizacja}). 


% ------------------------------------------------------------------------------
% DODATEK

\appendix

\chapter{Co nale¿y jeszcze zrobiæ w pracy}
\begin{itemize}
\item Uzupe³niæ brakuj¹ce fragmenty (TODO) - niektóre brakuj¹ce sekcje i cytowania.
\item Ustaliæ w jaki sposób odnieœæ siê do opisu niektórych bibliotek. Przyk³adowo, jeœli VisJs nie posiada ¿adnej publikacji naukowej, to czy powinien znaleŸæ siê w bibliografii? Mo¿e dobrym krokiem jest podanie adresu URL do dokumentacji biblioteki? Czy taki adres bêdzie w bibliografii?
\item Zaznaczyæ, ¿e do swojego programu odnoszê siê w skrócie jako Shimmer: Shimmer - Shimmering Constellations
\item Ujednoliciæ sposób nazywania niektórych rzeczy. Przyk³adowo': vis.js, VisJS, visJs
\item Ustaliæ sposób nazywania niektórych wyrazów z jêzyka angielskiego lub jakoœ sformatowaæ te wyst¹pienia. Przyk³adowo: framework, nazwy metryk.
\item Poprawiæ formatowanie tekstu w rozdziale o przebiegu analizy - u¿yæ funkcji pogrubienia tekstu i kursywy dla niektórych elementów.
\item Ustaliæ prawid³ow¹ klasyfikacjê tematyczn¹ pracy.
\item Przemyœleæ lepsze s³owa kluczowe.
\item Zmieniæ tytu³ / abstrakt tak, aby bardziej podkreœla³ rolê stworzonego oprogramowania w mojej pracy?
\item Usun¹æ ten dodatek.
\end{itemize}

\chapter{Oprogramowanie Shimmering Constellations}
Oprogramowanie opisane w pracy znajduje siê na za³¹czonej p³ycie CD oraz pod adresem: \url{http://students.mimuw.edu.pl/~fd305199/shimmer/shimmer.zip}

\chapter{Opis zawartoœci paczki z oprogramowaniem}
Za³¹czona paczka zawiera kod programu Shimmering Constellations napisany w jêzyku Java. W katalogu \verb+src\+ znajduje siê kod klas programu. W katalogu \verb+etc\thesis+ umieszczono kod Ÿród³owy tego dokumentu. Plik \verb+pom.xml+ zawiera zewstaw konfiguracji dla narzêdzie Maven, które mo¿e skompilowaæ program Shimmering Constellations. Skompilowany program znajdzie siê w katalogu \verb+target\+ i mo¿e zostaæ uruchomiony w œrodowisku uruchomieniowym Jboss 7.1.1.

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem[Erd2011]{bib_graph} Erdemir, U.; Tekin, U.; Buzluca, F., \textit{E-Quality: A graph based object oriented software quality visualization tool} Visualizing Software for Understanding and Analysis (VISSOFT), 2011 6th IEEE International Workshop on , vol., no., pp.1,8, 29-30 Sept. 2011

\bibitem[Deng11]{bib_const} Fang Deng; DiGiuseppe, N.; Jones, J.A., \textit{Constellation visualization: Augmenting program dependence with dynamic information}, Visualizing Software for Understanding and Analysis (VISSOFT), 2011 6th IEEE International Workshop on , vol., no., pp.1,8, 29-30 Sept. 2011

\bibitem[Jon02]{bib_taran} J. A. Jones, M. J. Harrold, and J. Stasko., \textit{Visualization of test information to assist fault localization}, Proceedings of the International
Conference on Software Engineering, ICSE ’02, pages 467–477, New York, NY, USA, 2002. ACM.

\bibitem[Ben13]{bib_heat} Benomar, O.; Sahraoui, H.; Poulin, P., \textit{Visualizing software dynamicities with heat maps}, Software Visualization (VISSOFT), 2013 First IEEE Working Conference on , vol., no., pp.1,10, 27-28 Sept. 2013

\bibitem[???1]{bib_metr} Tutaj muszê podaæ pracê zwi¹zan¹ z metrykami

\bibitem[???2]{bib_jdepend} Tutaj muszê podaæ pracê o JDepend

\bibitem[???3]{bib_findbugs} Tutaj muszê podaæ pracê o FindBugs

\bibitem[???4]{bib_findbugs} Tutaj muszê podaæ pracê / adres URL dokumentacji (???) o VisJs

\bibitem[???5]{bib_findbugs} Tutaj muszê podaæ pracê / adres URL dokumentacji (???) o HeatmapsJS

\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
