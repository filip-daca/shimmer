%
% Filip Daca - Praca magisterska
% Warszawa, czerwiec 2015
%
% Formatownie dokumentu - Copyright (c) 2001 by Marcin Woliñski <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie - Seweryn Kar³owicz, 05.05.2006

\documentclass{pracamgr}

\usepackage{float}
\usepackage{graphicx}
\usepackage{polski}
\usepackage[cp1250]{inputenc}
\usepackage{hyperref}
\usepackage{enumitem}

\author{Filip Daca}
\nralbumu{305199}
\title{Metody wizualizacji kodu Ÿród³owego w repozytorium wspomagaj¹ce analizê jakoœci}
\tytulang{Repository source code visualization methods supporting quality analysis}
\kierunek{Informatyka}

\opiekun{dr Robert D¹browski\\
  Instytut Informatyki\\
  }

\date{Czerwiec 2015}

\dziedzina{ 
11.3 Informatyka\\ 
}

\klasyfikacja{Software and its engineering $\rightarrow$ Software creation and management\\
Human-centered computing $\rightarrow$ Visualization $\rightarrow$ Visualization systems and tools}

\keywords{wizualizacja kodu, wizualizacja konstelacyjna, mapa termiczna, analiza projektów informatycznych, eksploracja repozytorium, narzêdzia in¿ynierii oprogramowania}

\newtheorem{defi}{Definicja}[section]

\begin{document}
\maketitle

\begin{abstract}
Mo¿liwoœæ przejrzystej wizualizacji du¿ego projektu informatycznego jest kluczowa przy analizie jego dotychczasowego rozwoju. Aby uskuteczniæ proces analizy, wizualizacja, oprócz obrazowania kodu, powinna uwzglêdniaæ metryki lub miary oceniaj¹ce elementy badanego systemu. Mo¿liwoœæ ujêcia takiej wizualizacji w ramach systemu kontroli wersji danego projektu pozwala skutecznie œledziæ rozwój oprogramowania i w szczególnoœci przewidywaæ niepo¿¹dane usterki. W pracy przedstawione s¹ ró¿ne metody wizualizacji kodu ze szczególnym naciskiem na wizualizacjê repozytorium i analizê jakoœci. Wybrane elementy zosta³y zaimplementowane w narzêdziu do analizy i wizualizacji kodu, które udostêpniono na zasadach Open Source.
\end{abstract}

\tableofcontents

\begingroup
	\let\cleardoublepage\relax
	\listoffigures
	\listoftables
	\clearpage
\endgroup

% ------------------------------------------------------------------------------
% ROZDZIA£ WSTÊP
% ------------------------------------------------------------------------------
\chapter*{Wprowadzenie}
\addcontentsline{toc}{chapter}{Wprowadzenie}

In¿ynieria oprogramowania jest szerok¹ dziedzin¹ obejmuj¹c¹ zagadnienia dotycz¹ce wytwarzania i zarz¹dzania oprogramowaniem. Analiza powstaj¹cego oprogramowania stanowi ga³¹Ÿ in¿ynierii, która ma du¿e znaczenie przy wytwarzaniu oprogramowania wysokiej jakoœci: niezawodnego, odpornego na usterki, rozszerzalnego. Jedn¹ z metod wspomagaj¹cych analizê oprogramowania jest wizualizacja - dziedzina zajmuj¹ca siê obrazowaniem oprogramowania. Istnieje wiele metod wizualizacji oprogramowania. Niektóre z metod mog¹ skutecznie wspomagaæ analizê jakoœci danego programu i umo¿liwiaæ wnioskowanie przysz³ych zmian zachodz¹cych w projekcie na podstawie jego historii. W swojej pracy opiszê trzy tego typu metody wizualizacji, które zaimplementowa³em w narzêdziu open-source wspomagaj¹cym analizê oprogramowania.

W rozdziale \ref{c:motivation} omówiê trzy wybrane metody wizualizacji i przedstawiê swoj¹ motywacjê do stworzenia oprogramowania. Rozdzia³ \ref{c:model} opisuje przyjêty przeze mnie model oprogramowania, który pozwala na realizacjê wybranych metod wizualizacji. W rozdziale \ref{c:software} przedstawiê architekrutê, budowê, dzia³anie i funkcjonalnoœæ stworzonego narzêdzia. Aby zweryfikowaæ wykorzystane w moim narzêdziu metody, pos³u¿ê siê przyk³adami oraz badaniem, które opiszê w rozdziale \ref{c:research}. Podsumowanie i perspektywy dalszego rozwoju narzêdzia zbiorê w rozdziale \ref{c:summary}.

% ------------------------------------------------------------------------------
% ROZDZIA£ MOTYWACJA
% ------------------------------------------------------------------------------
\chapter{Motywacja}\label{c:motivation}

Wizualizacja oprogramowania jest obszern¹ ga³êzi¹ in¿ynierii, która porusza koncepcje, techniki, metody i narzêdzia wspomagaj¹ce in¿ynieriê oprogramowania przez wizualn¹ prezentacjê wybranych treœci i zagadnieñ. Tematami podejmowanymi przy rozwa¿aniu tego typu wizualizacji s¹ czêsto projekty i systemy informatyczne, ich budowa, struktura, dzia³anie oraz ewolucja. Popularn¹ konferencj¹, która specjalizuje siê w metodach wizualizacji oprogramowania, jest organizowana przez Instytut In¿ynierów i Elektroników (and. IEEE - \textit{Institute of Electrical and Electronics Engineers}) konferencja VISSOFT - \textit{Visualizing Software for Understanding and Analysis} \cite{b:vissoft}. Wœród publikacji dotycz¹cych metod wizualizacji, zaprezentowanych na tej konferencji, skupi³em siê na pracach poruszaj¹cych nastêpuj¹ce aspekty:

\begin{enumerate}[label=(\alph*)]
\item Opis metody obrazowania kodu projektu - w jaki sposób wizualizowane jest oprogramowanie? 
\item Mo¿liwoœæ wizualizacji jakoœci kodu - czy opisywana metoda pozwala na obrazowania miar jakoœci? 
\item Uwzglêdnienie analizy historycznej kodu - czy wizualizacja uwzglêdnia i obrazuje zmiany w projekcie?
\end{enumerate}

¯adna z rozpatrywanych publikacji nie pokrywa³a siê w pe³ni z wszystkimi trzema aspektami, ale kilka prac w ciekawy sposób porusza³o czêœæ z nich. W tym rozdziale opiszê trzy wybrane artyku³y, które w interesuj¹cy sposób uwzglêdniaj¹ czêœæ z wy¿ej wymienionych aspektów, a pomys³y z tych prac zebrane w jedn¹ ca³oœæ mog¹ z³o¿yæ siê na przydatne narzêdzie wspieraj¹ce sztukê in¿ynierii oprogramowania.

\section{Wizualizacja grafowa}\label{s:motivation-graph}

W swojej pracy \cite{b:graph} U. Erdemir, U. Tekin i F. Buzluca proponuj¹ standardow¹ metodê wizualizacji kodu w postaci grafu. Autorzy skupiaj¹ siê na paradygmacie obiektowym i wizualizacji projektu na poziomie klas. Stworzone przez nich narzêdzie wydobywa metryki jakoœciowe z kodu Ÿród³owego analizowanego oprogramowania i przedstawia je w opartym na grafie interaktywnym œrodowisku. Proponowane podejœcie pomaga twórcom oprogramowania oceniæ jakoœæ kodu przez zastosowanie kategoryzacji atrybutów jakoœciowych i intuicyjne techniki wizualizacji.

\subsection{Wykorzystane techniki}

Autorzy w swoim narzêdziu wizualizuj¹ kod w postaci grafu, w którym wierzcho³ki reprezentuj¹ klasy, a krawêdzie oznaczaj¹ zale¿noœci miêdzy klasami, np.: dziedziczenie, implementacjê, widocznoœæ. Aby uskuteczniæ analizê jakoœci oprogramowania, autorzy klasyfikuj¹ wartoœci wybranych metryk na kategorie: \textit{niska}, \textit{umiarkowanie niska}, \textit{umiarkowanie wysoka} i \textit{wysoka}. Nastêpnie wizualizuj¹ te informacje za pomoc¹ nastêpuj¹cych technik:

\begin{itemize}
\item{Rozmiar wierzcho³ków} - zmieniaj¹c rozmiar wierzcho³ka obrazowany jest faktyczny rozmiar reprezentowanej klasy - niewielkie wierzcho³ki oznaczaj¹ klasy z niewielk¹ iloœci¹ metod, pól i instrukcji.
\item{Kolor wierzcho³ków} - przez manipulacjê kolorem wierzcho³ka, autorzy oddaj¹ z³o¿onoœæ danej klasy. Wierzcho³ki czerwone to klasy o du¿ej z³o¿onoœci, a wierzcho³ki niebieskie to klasy nieskomplikowane.
\item{Kszta³t wierzcho³ków} - modyfikuj¹c kszta³t wierzcho³ka oznaczany jest stopieñ zwi¹zania danej klasy. Wierzcho³ki w kszta³cie gwiazdy s¹ silnie zwi¹zane z innymi klasami, a wierzcho³ki o kszta³tach ³agodniejszych symbolizuj¹ klasy samodzielnie, lub o niskim powi¹zaniu.
\item{Kolor krawêdzi} - nadaj¹c odpowiedni kolor dla krawêdzi w grafie oznaczono rodzaj powi¹zania symbolizowanego przez dan¹ krawêdŸ. Przyk³adowo, kolor zielony oznacza implementacjê, a b³êkitny widocznoœæ.
\item{Gruboœæ krawêdzi} - przez modyfikacjê gruboœci krawêdzi autorzy oznaczaj¹ si³ê zale¿noœci reprezentowan¹ przez dan¹ krawêdŸ. Przyk³adowo, jeœli krawêdŸ oznacza wywo³ywanie metod z jednej klasy przez drug¹, gruboœæ krawêdzi bêdzie odwzorowywaæ iloœæ takich wywo³añ. 
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{bib3.png}
\caption{Projekt PDE wizualizowany w postaci grafu podany jako przyk³ad autorów pracy \cite{b:graph}}
\end{figure}

\subsection{Podsumowanie grafu}

Metoda zaproponowana przez autorów jest prosta w interpretacji i zrozumia³a dla u¿ytkownika. Za pomoc¹ grafu mo¿na w ³atwy sposób wizualizowaæ poszczególne cechy projektu nanosz¹c kolory na wybrane wierzcho³ki / krawêdzie. Autorzy potwierdzili eksperymentalnie, ¿e zastosowana przez nich metoda mo¿e byæ u¿yta do detekcji niedoskona³oœci projektowych i fragmentów kwalifikuj¹cych siê do refaktoryzacji. Opisana praca porusza wspomniane przeze mnie aspekty (a) oraz (b).

\section{Wizualizacja konstelacyjna}\label{s:motivation-constellation}

Ciekaw¹ metod¹ zaproponowan¹ przez F. Deng, N. DiGgiuseppe i J. A. Jones \cite{b:constellation} jest konstelacja. Ten sposób wizualizacji zosta³ opracowany w celu ³atwego wykrywania konkretnych fragmentów kodu oraz wizualnej separacji elementów nieinteresuj¹cych od istotnych (przyk³adowo klas wadliwych od prawid³owych). Wizualizacja konstelacyjna wygl¹dem przypomina gwieŸdziste niebo, na którym gwiazdy reprezentuj¹ poszczególne elementy kodu, a zale¿noœci miêdzy nimi s¹ obrazowane przez manipulacjê odleg³oœci¹. 

\subsection{Zasada budowy wizualizacji konstelacyjnej}

Wizualizacja konstelacyjna opiera siê w du¿ej mierze na modyfikacji wizualizacji grafowej i wzbogaceniu jej o dodatkowe efekty. W swojej pracy autorzy opisuj¹ kroki potrzebne do przetworzenia grafu zale¿noœci (o dowolnej granularnoœci) w konstelacjê. S¹ to kolejno:

\paragraph{Ukrycie krawêdzi:}
Dla lepszej skalowalnoœci uk³adu i interpretacji u¿ytkownika, w grafie zale¿noœci projektu nale¿y zrezygnowaæ z wizualizacji krawêdzi.

\paragraph{Uproszczenie wierzcho³ków:}
Dla lepszej rozszerzalnoœæ interpretacyjnej, wierzcho³ki powinny byæ wizualizowane jako pojedynczy punkt.

\paragraph{Kolorowanie wierzcho³ków na podstawie meta-danych:}
Dla obrazowania konkretnego problemu, wierzcho³ki powinny zostaæ pokolorowane wed³ug wybranych meta-danych. Przyk³adowo, jeœli interesuje nas jakoœæ wizualizowanego kodu, mo¿emy pos³ugiwaæ siê informacj¹ o jakoœci / liczbie usterek danego wierzcho³ka. Autorzy w swoich przyk³adach u¿yli informacji o podejrzanych instrukcjach pochodz¹cych z narzêdzia Tarantula rozwijanego w ramach prac nad detekcj¹ usterek \cite{b:tarantulla}

\paragraph{Nadanie si³ krawêdziom:}
Dla u³atwienia interpretacji i lepszego powi¹zania kontekstowego wizualizowanych wierzcho³ków, krawêdzie powinny swoj¹ d³ugoœci¹ reprezentowaæ si³ê powi¹zania. Autorzy zastosowali w swoich przyk³adach informacje pozyskane przy dynamicznej analizie projektu.

\paragraph{Równowa¿enie / klastrowanie:}
Aby metoda pozwala³a jeszcze dok³adniej interpretowaæ wizualizacjê pod k¹tem konkretnego problemu, konstelacja mo¿e zrównowa¿yæ po³o¿enie wierzcho³ków. Zamys³em autorów by³o wizualne rozdzielenie grup wierzcho³ków o wspólnych cechach. W swoim przyk³adzie autorzy wprowadzili kategoryzowanie uruchomieñ, aby wzbogaciæ informacje z dynamicznej analizy.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{bib1.png}
\caption{Projekt Gzip wizualizowany w postaci konstelacji podany jako przyk³ad autorów pracy \cite{b:constellation}}
\end{figure}

\subsection{Badania potwierdzaj¹ce skutecznoœæ konstelacji}

Autorzy pracy przeprowadzili badania, które potwierdzi³y skutecznoœæ metody konstelacyjnej. W teœcie wziê³o udzia³ 30 studentów informatyki uniwersytetu w Kalifornii, o ró¿nym stopniu doœwiadczenia. Do testu przygotowano 4 projekty informatyczne, w których kodzie umieszczono co najmniej 20 losowych usterek. Nastêpnie na podstawie wizualizacji konstelacyjnej oraz mapy kodu uczestnicy badania mieli wskazaæ przypuszczaln¹ lokalizacjê usterki przez oznaczenie odpowiednich elementów kodu. Obie wizualizacje by³y oznaczone kolorami na podstawie meta-danych dostarczonych przez narzêdzie analizuj¹ce jakoœæ kodu i obrazowa³y kod na poziomie instrukcji. Dziêki temu autorzy byli w stanie w mierzalny sposób stwierdziæ, jaka objêtoœæ kodu jest podejrzana wed³ug uczestników badania. W wyniku testu autorzy wykazali, ¿e w ka¿dym przypadku wizualizacja konstelacyjna wymaga³a od u¿ytkowników przejrzenia znacznie mniejszej liczby linii kodu ni¿ w przypadku wizualizacji mapy SeeSoft.

\subsection{Wnioski i podsumowanie konstelacji}

Wizualizacja konstelacyjna jest metod¹, która dobrze nadaje siê wielu zastosowañ in¿ynierii oprogramowania i mo¿na j¹ przeprowadziæ uzupe³niaj¹c graf wizualizowanego projektu o odpowiednie metadane. Skutecznoœæ metody potwierdzono badaniami, w których wykazano, ¿e programiœci potrzebuj¹ mniej czasu na identyfikacjê usterek w kodzie, kiedy pos³uguj¹ siê konstelacj¹, w porównaniu do mapy dokumentu. Opisana praca porusza wspomniane przeze mnie aspekty (a) oraz (b).

\section{Mapa termiczna}\label{s:motivation-heatmap}

Praca autorstwa O. Benomar, H. Sahraoui, P. Poulin \cite{b:heatmaps} przedstawia kilka interesuj¹cych zastosowañ mapy termicznej w wizualizacji projektów. W swojej pracy autorzy opisuj¹ metodê wizualizacji kodu w postaci miast i budynków, a wykorzystana w tle mapa termiczna s³u¿y do oznaczania dynamiki projektu. Istotnym zamys³em autorów by³o dok³adne opisanie rozwi¹zañ graficznych u¿ytych przy integracji mapy z g³ówn¹ wizualizacj¹.

\subsection{Zastosowania}

Mapy termiczne s¹ dwuwymiarowymi obiektami wykorzystuj¹cymi metaforê ciep³a do reprezentowania intensywnoœci lub wa¿noœci poszczególnej cechy. W zale¿noœci od rozk³adu wybranej cechy, kolory mapy termicznej interpoluj¹ ze sob¹ tworz¹c wyraŸnie obserwowalne otoczenia o wiêkszym zagêszczeniu danej w³aœciwoœci. Taki charakter map termicznych mo¿e mieæ zastosowanie w wizualizacji zmian zachodz¹cych w projekcie. Autorzy rozwa¿aj¹ przyk³ady oparte na historycznych w³aœciwoœciach kodu:

\paragraph{Czas zmian:} Zastosowanie mapy termicznej do obrazowania wieku ostatniej zmiany danego fragmentu kodu. Autorzy wizualizuj¹c projekt w postaci miast, klasy programu przedstawiali w formie budynków. Budynki na tle o wysokiej temperaturze oznacza³y klasy, które by³y niedawno modyfikowane. Taka wizualizacja umo¿liwia analizê zagadnieñ: 

\begin{itemize}
\item Nad jak¹ czêœci¹ projektu trwaj¹ aktualnie prace? 
\item Które elementy projektu nie by³y od dawna zmieniane?
\end{itemize}

\paragraph{Iloœæ zmian:} U¿ycie mapy termicznej do oznaczenia ca³kowitej liczby zmian danego fragmentu kodu. Autorzy wysok¹ temparatur¹ oznaczaj¹ klasy czêsto modyfikowane. Takie podejœcie pozwala znaleŸæ odpowiedzi na pytania:

\begin{itemize}
\item Która klasa / fragment oprogramowania jest najpopularniejszy? 
\item Które elementy projektu ulegaj¹ czêstym zmianom, a które pozostaj¹ niezmodyfikowane?
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{bib2.png}
\caption{Projekt JHotDraw wizualizowany w postaci miasta przy u¿yciu mapy termicznej w przyk³adzie z pracy \cite{b:heatmaps}}
\end{figure}

\subsection{Wnioski i podsumowanie map termicznych}

Mapa termiczna mo¿e byæ dodatkowym elementem wizualizacji, który w dobry sposób oddaje dynamikê projektu. Rozmyty charakter obrazowania termicznego, szczególnie wykorzystany w tle konkretnej wizualizacji, rozszerza otoczenie pojedynczych elementów i przyczynia siê do powstawania obszarów o konkretnych w³aœciwoœciach. Przyk³adowo - obszary o wiêkszej temperaturze mog¹ obrazowaæ skupiska kodu czêsto modyfikowanego. Opisana praca porusza wspomniane przeze mnie aspekty (a) oraz (c).

% ------------------------------------------------------------------------------
% ROZDZIA£ MODEL
% ------------------------------------------------------------------------------
\chapter{Model}\label{c:model}

Aby przygotowaæ wizualizacjê, która zobrazuje kod projektu informatycznego uwzglêdniaj¹c jego jakoœæ i dane historyczne, nale¿y ustaliæ odpowiedni model reprezentuj¹cy program komputerowy. W tym rozdziale przedstawiê model, który przyj¹³em do reprezentacji oprogramowania w swojej pracy.

\section{Oprogramowanie jako graf}\label{s:model-graph}

W swojej pracy ograniczy³em siê do analizy kodu na poziomie pakietów. Przyjêty przeze mnie model analizowanego projektu ma strukturê skierowanego grafu, w którym wierzcho³ki reprezentuj¹ pakiety programu, a krawêdzie zale¿noœci miêdzy nimi. Przyjêty model ilustruje rysunek \ref{i:model} oraz \ref{i:model-more}

\subsection{Wierzcho³ki}

Ka¿dy wierzcho³ek grafu posiada swój typ i nazwê pakietu, który reprezentuje. W zale¿noœci od typu, wierzcho³ek mo¿e posiadaæ te¿ inne atrybuty. W modelu wyró¿niamy nastêpuj¹ce typy wierzcho³ków:

\begin{itemize}
\item \textbf{Wierzcho³ki pakietowe} - reprezentuj¹ pakiety analizowanego projektu.
	\begin{itemize}
	\item \textbf{Wierzcho³ki pakietów analizowanych} - s¹ to pakiety, dla których chcielibyœmy przeprowadziæ analizê jakoœci i wydobyæ dane historyczne. W rzeczywistoœci ten rodzaj wierzcho³ków reprezentuje fragmenty kodu stworzone w procesie realizacji danego projektu.
	\item \textbf{Wierzcho³ki pakietów bibliotecznych} - s¹ to pakiety, które wchodz¹ w sk³ad projektu ale nie podlegaj¹ szczegó³owej analizie jakoœciowej i historycznej. Wierzcho³ki te mog¹ reprezentowaæ biblioteki zewnêtrzne, które zosta³y za³¹czone do analizowanego projektu, bez ingerencji w ich kod. Przyk³adem mo¿e byæ pakiet \texttt{java.lang}, który jest u¿ywany w projekcie, ale definicja jego klas nie znajduje siê w kodzie Ÿród³owym projektu.
	\end{itemize}
\item \textbf{Wierzcho³ki katalogowe} - s¹ to pakiety, które nie posiadaj¹ swoich klas, ale zawieraj¹ inne pakiety. Wierzcho³ki te mog¹ byæ rozumiane jako katalogi w drzewie katalogów projektu, gdy¿ reprezentuj¹ kolejne elementy œcie¿ki danego pakietu. Przyk³adowymi wierzcho³kami katalogowymi bêd¹ \texttt{org} oraz \texttt{org.apache}, jeœli w projekcie znajduje siê pakiet \texttt{org.apache.commons.io}.
\end{itemize}

\subsection{Krawêdzie}

Ka¿da krawêdŸ grafu posiada swój typ, oraz jest w stanie okreœliæ ³¹czone wierzcho³ki i si³ê powi¹zania miêdzy nimi. Wyró¿niamy dwa rodzaje krawêdzi:

\begin{itemize}
\item \textbf{Krawêdzie drzewa pakietów} - odzwierciedlaj¹ strukturê fizyczn¹ programu. Tego typu krawêdziami po³¹czone s¹ wierzcho³ki bêd¹ce w relacji “ojciec - syn” w drzewie pakietów. Przyk³adowo, pakiet \texttt{shimmer.service.impl} znajduje siê wewn¹trz pakietu \texttt{shimmer.service}, wiêc ich wierzcho³ki bêd¹ po³¹czone tak¹ krawêdzi¹. Równie¿ w tym przypadku sztuczny wierzcho³ek katalogowy \texttt{shimmer} po³¹czony bêdzie z wierzcho³kiem pakietowym \texttt{shimmer.service}. Si³a powi¹zania dla takich krawêdzi jest sta³a.
\item \textbf{Krawêdzie zale¿noœci miêdzy pakietami} - odzwierciedlaj¹ logiczne powi¹zania ³¹cz¹ce pakiety. Tego typu krawêdziami powi¹zane s¹ pakiety, których klasy korzystaj¹ z siebie nawzajem. Przyk³adowo, jeœli jakaœ klasa pakietu \texttt{shimmer.service} polega na innej klasie z pakietu \texttt{shimmer.service.impl}, pakiety po³¹czone bêd¹ tak¹ krawêdzi¹. Si³a takiego powi¹zania mo¿e byæ ró¿na, w zale¿noœci od liczby zale¿nych klas, dlatego krawêdzie tego typu posiadaæ bêd¹ ró¿ne wartoœci si³y oddzia³ywania.
\end{itemize}

\begin{figure}[t]
\centering
\includegraphics[width=0.6\textwidth]{model1.png}
\caption{Fragment grafu projektu Hibernate - na przyk³adzie widoczne s¹ krawêdzie drzewa pakietów, zielone wierzcho³ki pakietowe, szare wierzcho³ki biblioteczne oraz niebieskie wierzcho³ki katalogowe. Dla zwiêkszenia czytelnoœci krawêdzie zale¿noœci zosta³y ukryte. Szczegó³owe zbli¿enie przedstawiono na rysunku \ref{i:model-more}}
\label{i:model}
\end{figure}

\begin{figure}[t]
\centering
\includegraphics[width=0.6\textwidth]{model2.png}
\caption{Zbli¿enie fragmentu grafu z rysunku \ref{i:model}. Na zbli¿eniu widaæ etykiety pakietów reprezentowanych przez poszczególne wierzcho³ki.}
\label{i:model-more}
\end{figure}

\section{Potencjalne usterki}\label{s:model-bugs}

Chc¹c uwzglêdniæ w wizualizacji podejrzane fragmenty oprogramowania, wprowadzamy do modelu pojêcie \textit{potencjalnej usterki}. Obiekty te wyra¿aj¹ wykryte zagro¿enie, które mo¿e prowadziæ do powstawania b³êdów w przysz³oœci. Wykryta usterka dotyczyæ mo¿e dowolnego fragmentu kodu - w zaproponowanym modelu ka¿dy wierzcho³ek pakietu analizowanego bêdzie grupowa³ potencjalne usterki wykryte w obrêbie danego pakietu.

Ka¿da potencjalna usterka posiada szereg atrybutów charakteryzuj¹cych zagro¿enie:

\begin{itemize}
\item \textbf{Lokalizacja b³êdu} - pozwala ustaliæ, w jakim fragmencie kodu wystêpuje dana usterka. Ta informacja powinna jednoznacznie wskazywaæ pakiet, w którym wykryto usterkê, ale równie¿ pozwalaæ na dok³adniejsze zlokalizowanie problemu w kodzie programu.
\item \textbf{Typ b³êdu} - okreœla na czym polega wykryta usterka. Na podstawie tej informacji jesteœmy w stanie znaleŸæ rozwi¹zanie dla wykrytego problemu.
\item \textbf{Priorytet b³êdu} - kategoryzuje usterki ze wzglêdu na ich wa¿noœæ.
\item \textbf{Pewnoœæ} - zaproponowane pojêcie usterki ma symbolizowaæ fragment podejrzany, dlatego istotn¹ informacj¹ jest miara przekonania o wyst¹pieniu danego problemu w przysz³oœci. 
\end{itemize}


\section{Metryki i miary jakoœciowe}\label{s:model-metrics}

Aby móc analizowaæ projekt pod k¹tem jakoœciowym, rozwa¿amy szereg metryk oddaj¹cych charakter badanego kodu. W swojej pracy ograniczam siê do wybranych metryk projektowych na poziomie pakietowym \cite{b:metrics}. Wartoœci poszczególnych metryk w tym przypadku dotycz¹ konkretnych pakietów, a w opisywanym modelu s¹ atrybutami \textit{wierzcho³ków pakietów analizowanych}.

\paragraph{Number of Classes and Interfaces / Class count (Cc)}~\\
Liczba klas konkretnych, klas abstrakcyjnych, oraz interfejsów w pakiecie jest miar¹ rozszerzalnoœci pakietu.

\paragraph{Concrete Classes}~\\
Liczba klas konkretnych w pakiecie. Na podstawie tej metryki jesteœmy w stanie okreœliæ jak¹ czêœæ pakietu stanowi implementacja / kod wykonywany.

\paragraph{Abstract Classes (Ac)}~\\
Liczba klas abstrakcyjnych i interfejsów w pakiecie. Wartoœæ tej metryki pozwala nam stwierdziæ jak¹ czêœæ pakietu stanowi¹ abstrakcje projektowe.  

\paragraph{Total Size (Ts)}~\\
Rozmiar ca³kowity. Suma rozmiarów wszystkich klas z pakietu. Dziêki tej metryce, w odró¿nieniu od liczby klas, mo¿emy dok³adniej zobrazowaæ faktyczny rozmiar pakietu.

\paragraph{Largest Class Size}~\\
Rozmiar najwiêkszej klasy z pakietu. Ta metryka pozwala nam w ³atwy sposób wskazaæ pakiety, w których znajduj¹ siê klasy o zbyt du¿ej z³o¿onoœci - byæ mo¿e wymagaj¹ce refaktoryzacji.

\paragraph{Average Size (As)}~\\
Œredni rozmiar klas. Liczony jako œrednia arytmetyczna rozmiaru klas z dzieleniem ca³kowitym. Metryka pozwala na ogólne zobrazowanie rozmiaru pakietu ze wzglêdu na rozmiar klas, a nie iloœæ.

\begin{equation}
As = Ts / Cc
\end{equation}

\paragraph{Afferent Couplings (Ca)}~\\
Powi¹zania aferentne - liczba innych pakietów, które polegaj¹ na klasach z pakietu danego. Metryka wyra¿a odpowiedzialnoœæ (responsibility) danego pakietu.

\paragraph{Efferent Couplings (Ce)}~\\
Powi¹zania eferentne - liczba innych pakietów, na których polegaj¹ klasy z pakietu danego. Metryka wyra¿a zale¿noœæ (dependency) danego pakietu.

\paragraph{Abstractness (A)}~\\
Abstrakcyjnoœæ - stosunek liczby interfejsów i klas abstrakcyjnych do liczby wszystkich klas z danego pakietu. Metryka przyjmuje wartoœci z przedzia³u od $0$ do $1$, gdzie $0$ oznacza pakiet w pe³ni konkretny, a $1$ pakiet ca³kowicie abstrakcyjny.

\begin{equation}
A = Ac / Cc
\end{equation}

\paragraph{Instability (I)}~\\
Niestabilnoœæ - stosunek liczby powi¹zañ eferentnych do liczby wszystkich powi¹zañ pakietu. Metryka wyra¿a podatnoœæ pakietu na zmiany. Przyjmuje wartoœci z przedzia³u od $0$ do $1$, gdzie $0$ oznacza pakiet w pe³ni stabilny (nie zmienia siê w wyniku zmian innych pakietów), a $1$ oznacza pakiet ca³kowicie niestabilny (zale¿ny od pozosta³ych).

\begin{equation}
I = Ce / (Ce + Ca)
\end{equation}

\paragraph{Distance from the Main Sequence (D)}~\\
Odleg³oœæ od idealnej linii równania $A + I = 1$. Zgodnie z za³o¿eniami dobrych praktyk projektowych opisanych w pracy \cite{b:metrics} pakiety powinny byæ abstrakcyjne lub niestabilne. Pakiety osadzone na linii tego równania zachowuj¹ odpowiedni balans pomiêdzy abstrakcj¹ a stabilnoœci¹. Przyjmuje wartoœci z przedzia³u od $0$ do $1$, gdzie $0$ oznacza pakiet zgodny z g³ównym za³o¿eniem, a $1$ oznacza pakiet mo¿liwie najdalej oddalony od idealnego równania.

\paragraph{Abstract or Instable (AoI)}~\\
Metryka wyra¿a balans pakietu pomiêdzy abstrakcj¹, a niestabilnoœci¹ - stwierdza, czy w danym pakiecie przewa¿a abstrakcyjnoœæ, czy niestabilnoœæ - zgodnie z za³o¿eniami o odleg³oœci od idealnej sekwencji. Ta miara pozwala podzieliæ pakiety ze wzglêdu na ich charakter. Przyjmuje wartoœci od $-1$ do $1$, gdzie $-1$ oznacza pakiet, w którym w pe³ni przewa¿a niestabilnoœæ, a $1$ oznacza pakiet zdominowany przez abstrakcjê.

\begin{equation}
AoI = A - I
\end{equation}

\paragraph{Total Bugs}~\\
Liczba usterek, które zosta³y wykryte wewn¹trz pakietu. Jest to metryka za pomoc¹ której w czytelny sposób mo¿na wizualizowaæ jakoœæ kodu.

\section{Statystyki historyczne}\label{s:model-history}

Chc¹c badaæ projekt pod k¹tem zmian zachodz¹cych w jego kodzie Ÿród³owym, pos³ugujemy siê wybranymi statystykami historycznymi pakietów. Na podstawie tych danych mo¿emy wnioskowaæ na temat charakteru poszczególnych fragmentów kodu i ich roli w projekcie. Ponadto, pos³uguj¹c siê informacjami historycznymi jesteœmy w stanie przewidzieæ, które elementy bêd¹ pogleda³y czêstym zmianom w przysz³oœci \cite{b:historical-metrics}.

\paragraph{Authors Count}~\\
Liczba autorów, którzy wprowadzali zmiany do danego pakietu na podstawie historii z systemu kontroli wersji. Pakiety, nad którymi pracowa³a du¿a liczba autorów mog¹ zawieraæ g³ówn¹ funkcjonalnoœæ projektu.

\paragraph{Total Commits}~\\
Liczba wszystkich zmian w systemie kontroli wersji, które dotyczy³y danego pakietu. Metryka wskazuje na z³o¿onoœæ danego pakietu. Kod, który posiada wiele kontrybucji prawdopodobnie:

\begin{itemize}
\item dotyczy jednej z g³ównych funkcjonalnoœci projektu - jest stale rozwijany
\item jest podatny na zmiany / usterki - wymaga czêstej refaktoryzacji
\end{itemize}

\paragraph{Last Commit}~\\
Data ostatniej zmiany w systemie kontroli wersji. Dla u¿ytkownika mo¿e wskazywaæ hermetyczny charakter pakietu - kod, który od d³ugiego czasu nie by³ zmieniany prawdopodobnie:

\begin{itemize}
\item jest solidny i nie wymaga poprawek,
\item nie dotyczy ¿adnej g³ównej, rozwijanej w projekcie funkcjonalnoœci,
\item jest kodem który trudno zmieniæ
\end{itemize}

\section{Droga do wizualizacji}\label{s:model-analysis}

Zaproponowany w tym rozdziale model oprogramowania pozwala wyznaczyæ listê kroków koniecznych do wykonania wizualizacji wybranego projektu:

\begin{enumerate}
\item Rekonstrukcja grafu - odtworzenie struktury programu komputerowego.
\item Przeszukiwanie usterek i uzupe³nienie modelu o zestaw wykrytych b³êdów w ka¿dym z wierzcho³ków.
\item Wyliczenie wartoœci metryk i uzupe³nienie modelu o informacje jakoœciowe dla ka¿dego z wierzcho³ków.
\item Analiza repozytorium projektu i uzupe³nienie modelu o informacje historyczne dla ka¿dego z wierzcho³ków.
\item Przygotowanie modelu do wizualizacji - zmapowanie elementów modelu i ich atrybutów na konkretne obiekty graficzne wed³ug wybranej metody wizualizacji.
\end{enumerate}

\section{Wizualizacja modelu - realizacja za³o¿eñ}

Przy pomocy zaproponowanego modelu opartego na grafie, jesteœmy w stanie w bezpoœredni sposób przeprowadziæ wizualizacjê kodu projektu w postaci grafowej [dzia³ \ref{s:motivation-graph}]. Poprzez odpowiedni¹ modyfikacjê œrodków wyrazu takich jak rozmiar, kolor, kszta³t wierzcho³ków oraz d³ugoœæ krawêdzi mo¿emy wyraziæ wartoœci wybranych metryk. Dziêki temu wzbogacimy wizualizacjê o informacje jakoœciowe. Dobór metryk i manipulacja elementami graficznymi pozwala nam na rozszerzenie wizualizacji grafowej i utworzenie na jej podstawie wizualizacji konstelacyjnej [dzia³ \ref{s:motivation-constellation}. Informacje historyczne o danym projekcie s¹ podstaw¹ do wykorzystania mapy termicznej [dzia³ \ref{s:motivation-heatmap}].

\subsection{Œrodki wyrazu}
Wybrane metody wizualizacji pozwalaj¹ nam na manipulacjê nastêpuj¹cymi atrybutami:

\begin{description}
\item[Rozmiar wierzcho³ka (iloœæ)] - pos³uguj¹c siê tym parametrem, mo¿emy w naturalny sposób odzwierciedlaæ iloœciow¹ charakterystykê kodu. U¿ytkownik jest w stanie ³atwo skojarzyæ wielkoœæ wierzcho³ka z liczb¹ klas w pakiecie lub ca³kowit¹ liczb¹ linii kodu.
\item[Kolor wierzcho³ka (jakoœæ)] - pozwala zobrazowaæ jakoœæ wizualizowanego kodu, zw³aszcza zestawiaj¹c kolory ze skali od czerwonego do zielonego. Osoba ogl¹daj¹ca wizualizacjê mo¿e rozpoznaæ czerwone wierzcho³ki jako pakiety niskiej jakoœci, a zielone wysokiej. Oprócz jakoœci, kolor mo¿e równie¿ oddawaæ charakterystykê badanego elementu. Przyk³adowo wierzcho³ki pakietów bibliotecznych mog¹ byæ wyró¿nione od pozosta³ych przez sta³y kolor szary, a wierzcho³ki katalogowe kolor niebieski.
\item[Temperatura wierzcho³ka (aktywnoœæ)] - stanowi pomocniczy sposób wyrazu i mo¿e s³u¿yæ do obrazowania cech szczególnych kodu, które podlegaj¹ stopniowaniu. Dobrym zastosowaniem tego parametru jest zobrazowanie staystyk historycznych danego pakietu - u¿ytkownik mo¿e rozpoznaæ wierzcho³ki gor¹ce jako “aktywne”, a ch³odne jako stabilne, niezmienne. 
\item[D³ugoœæ krawêdzi (zale¿noœæ)] - pozwala w ³atwy sposób zobrazowaæ si³ê powi¹zania miêdzy poszczególnymi elementami. Wierzcho³ki znajduj¹ce siê blisko siebie w znormalizowanym grafie, s¹ od siebie silnie zale¿ne, a wierzcho³ki oddalone nie maj¹ mocnych powi¹zañ.
\end{description}


% ------------------------------------------------------------------------------
% ROZDZIA£ APLIKACJA
% ------------------------------------------------------------------------------
\chapter{Narzêdzie Shimmering Constellations}\label{c:software}

Wybrane elementy metod wizualizacji postanowi³em zaimplementowaæ w narzêdziu open-source, które w przystêpny sposób pozwoli³oby u¿ytkownikowi wizualizowaæ projekty informatyczne z uwzglêdnieniem analizy jakoœciowej i historycznej.

W tym rozdziale opiszê budowê oraz dzia³anie aplikacji Shimmering Constellations, która ³¹czy techniki wizualizacji grafowej i konstelacyjnej z wykorzystaniem mapy termicznej.

\section{Architektura aplikacji}\label{r:architektura}
\subsection{Zr¹b i technologia}

Technologia, która wyda³a mi siê odpowiednia dla mojego rozwi¹zania to Java EE. Argumenty, które przyczyni³y siê do podjêcia tej decyzji to dostêpnoœæ szerokiej gamy bibliotek analizy kodu Ÿród³owego, rozbudowane narzêdzia wizualizacyjne dzia³aj¹ce w œrodowisku przegl¹darki internetowej (vis.js), oraz uniwersalnoœæ i skalowalnoœæ architektury. Stworzone przeze mnie narzêdzie ma charakter aplikacji webowej opartej na frameworku Spring, wykorzystuj¹cej biblioteki JSF PrimeFaces. Œrodowiskiem uruchomieniowym aplikacji jest serwer JBoss 7, ale nie jest to wymogiem koniecznym - przy niewielkim nak³adzie pracy mo¿liwe jest uruchomienie Shimmering Constellations na dowolnym œrodowisku aplikacji webowych JEE. Przy u¿yciu narzêdzia automatyzuj¹cego Maven, mo¿liwe jest proste dodawanie zewnêtrznych bibliotek do projektu.

Dziêki tym za³o¿eniom projektowym, aplikacja mo¿e byæ w ³atwy sposób uruchomiona na serwerze uczelni i udostêpniona dla studentów oraz naukowców poprzez interfejs przegl¹darki internetowej - bez koniecznoœci instalacji ca³ego pakietu na swoim komputerze. Ponadto aplikacjê mo¿na w prosty sposób zintegrowaæ z dowoln¹ baz¹ danych w celu katalogowania wyników analiz.

\subsection{Struktura logiczna}

Aplikacja opiera siê na wzorcu architektonicznym Model-View-Controller w celu rozs¹dnego rozdzielenia logiki problemu od interfejsu u¿ytkownika. Przyjêty przeze mnie model symulacji sk³ada siê z grafu przeanalizowanego projektu, w którym wierzcho³ki reprezentuj¹ poszczególne pakiety, a ga³êzie zale¿noœci miêdzy nimi. Widokiem aplikacji jest strona internetowa prezentuj¹ca wizualizacjê oraz udostêpniaj¹ca formularze i elementy steruj¹ce dla u¿ytkownika. Kontroler aplikacji pobiera dane od u¿ytkownika, uruchamia poszczególne serwisy analizy, które konstruuj¹ a nastêpnie przetwarzaj¹ model, aby ostatecznie przedstawiæ wynik wizualizacji w widoku.

\section{Biblioteki wspomagaj¹ce analizê}

Wszystkie narzêdzia u¿yte w projekcie Shimmering Constellations s¹ stworzone w jêzyku Java i udostêpnione publicznie na licencjach otwartego oprogramowania. Dostêpnoœæ gotowych rozwi¹zañ wspomagaj¹cych analizê by³a jednym z g³ównych czynników decyduj¹cych o technologii u¿ytej w ca³ym projekcie.

\subsection{JDepend}

Narzêdzie JDepend \cite{b:jdepend} pozwala analizowaæ programy stworzone w jêzyku Java, na podstawie ich kodu skompilowanego. G³ównym zadaniem biblioteki jest przegl¹danie plików klas i zbieranie informacji dotycz¹cych metryk projektowych na poziomie pakietów. Metryki badane przez JDepend pomagaj¹ zbadaæ jakoœæ oprogramowania i wskazaæ ukryte w nim wady projektowe. Wyniki analizy mog¹ byæ prezentowane w czystej postaci tekstowej, struktury xml lub w interfejsie graficznym.

Narzêdzie nie dostarcza programistycznego API, wiêc aby móc w pe³ni wykorzystaæ mo¿liwoœci dostarczane przez JDepend, wydzieli³em kod odpowiedzialny za analizê Ÿróde³ i do³¹czy³em go do aplikacji Shimmering Constellations. Dziêki temu by³em w stanie programistycznie pozyskaæ wyniki analizy, bez koniecznoœci zbêdnej serializacji i deserializacji. Ponadto licencja, na której opublikowano JDepend pozwoli³a mi wprowadziæ zmiany w kodzie analizuj¹cym, aby dok³adniej zmierzyæ si³ê zale¿noœci miêdzy analizowanymi pakietami.

Dziêki funkcjonalnoœci dostarczanej przez JDepend, Shimmering Constellations jest w stanie zbudowaæ model analizowanego programu w postaci grafu [dzia³ \ref{s:model-graph}], oraz policzyæ wartoœci niektórych podstawowych metryk projektowych [dzia³ \ref{s:model-metrics}].

\subsection{Findbugs}

Findbugs \cite{b:findbugs} jest programem przeprowadzaj¹cym statyczn¹ analizê kodu skompilowanego Javy w celu detekcji potencjalnych usterek. Dzia³anie narzêdzia opiera siê na koncepcji wzorców usterek (Bug Patterns), które czêsto prowadz¹ do powstawania b³êdów. Analizator przy pomocy zaawansowanych heurystyk przeszukuje kod projektu w poszukiwaniu wzorców usterek. G³ównym celem twórców biblioteki by³o stworzenie zestawu heurystyk opartych o nauczanie maszynowe, pozwalaj¹cych na wykrywanie potencjalnych usterek z niskim wspó³czynnikiem false-positive. Autorzy podkreœlaj¹, ¿e w praktyce szansa detekcji false-positive jest mniejsza ni¿ 50\%.

Narzêdzie powsta³o na uniwersytecie Maryland w 2004 r. i jest stale rozwijane.

Pakiet FindBugs za³¹czony zosta³ do projektu w postaci zale¿noœci dla narzêdzia Maven. Skompilowane klasy Finndbugs 3.0.1 wraz z kodem Ÿród³owym zosta³y pobrane automatycznie i do³¹czone do œrodowiska uruchomieniowego aplikacji.

Wyniki analizy Findbugs pozwol¹ narzêdziu Shimmering Constellations wskazaæ potencjalne zagro¿enia wykryte w klasach analizowanego projektu [dzia³ \ref{s:model-bugs}].

\subsection{JGit}

JGit \cite{b:jgit} jest wydajn¹ implementacj¹ systemu kontroli wersji GIT dla jêzyka Java. Pozwala na pracê z repozytoriami GIT w œrodowisku programistycznym, ale nie udostêpnia gotowych metod pozyskuj¹cych metryki historyczne projektu. W zwi¹zku z tym proces wyliczenia odpowiednich miar musia³em zaimplementowaæ samodzielnie.

Biblioteki JGit równie¿ zosta³y dodane do projektu jako zale¿noœæ projektowa programu Maven i nie by³y przeze mnie modyfikowane.

Dziêki informacjom pozyskiwanym przez JGit, Shimmering Constellations potrafi wyliczyæ podstawowe metryki historyczne [dzia³ \ref{s:model-history}] - wskazaæ ostatnio modyfikowane elementy projektu, czêsto zmieniane pakiety, oraz podaæ liczbê ich autorów.

\section{Implementacja modelu}\label{s:software-implementation}

Implementuj¹c opisany w rozdziale \ref{c:model} model grafu stara³em siê zadbaæ o zachowanie dobrych praktyk projektowych oraz wydajny dostêp do poszczególnych wierzcho³ków. Ze wzglêdu na krokowy charakter analizy w Shimmering Constellations [dzia³ \ref{s:model-analysis}], dostêp do poszczególnych wierzcho³ków oraz krawêdzi powinien odbywaæ siê w czasie sta³ym. 

Zaimplementowany graf posiada kolekcjê wierzcho³ków i krawêdzi oraz zbiór metod umo¿liwiaj¹cych wykonywanie podstawowych czynnoœci na swojej strukturze. Wierzcho³ki przechowywane s¹ w posortowanej hash-mapie (klasa \verb+LinkedHashMap+), gdzie kluczem jest pe³na nazwa pakietu identyfikuj¹ca wierzcho³ek. Kolekcja zbieraj¹ca krawêdzie jest posortowanym hash-zbiorem (klas \verb+LinkedHashSet+). Dziêki temu dla obu kolekcji mo¿liwa jest iteracja w ustalonej kolejnoœci, a czas wykonania kluczowych operacji jest optymalny:

\begin{itemize}
\item wyszukiwanie wierzcho³ka po nazwie: $\mathcal{O}(1)$
\item wyszukanie pakietu nadrzêdnego (ojca w drzewie pakietów) dla danego wierzcho³ka: $\mathcal{O}(1)$
\item dodawanie wierzcho³ka oraz krawêdzi drzewa pakietów: $\mathcal{O}(1)$
\item dodawanie krawêdzi zale¿noœci: $\mathcal{O}(1)$
\end{itemize}

Do konstruowania poszczególnych wierzcho³ków i krawêdzi wykorzysta³em wzorzec projektowy “fabryka”.

Taki sposób implementacji modelu jest ³atwo rozszerzalny i pozwala na proste rozbudowanie funkcjonalnoœci Shimmering Constellations w przysz³oœci, np. zwiêkszenie granularnoœci przez dodanie wierzcho³ków klasowych do modelu [dzia³ \ref{s:summary-future}].

\section{Przebieg dzia³ania programu - przygotowanie wizualizacji}\label{s:software-analysis}

Zebrane biblioteki i wybór implementacji modelu pozwalaj¹ na skuteczne przygotowanie danego projektu do wizualizacji [dzia³ \ref{s:model-analysis}]. Kroki potrzebne do wstêpnego przeanalizowania projektu przes Shimmering Constellations opisa³em w tej sekcji.

Analiza projektu rozpoczyna siê w momencie, gdy u¿ytkownik zdefiniuje œcie¿kê prowadz¹c¹ do plików skompilowanych projektu i u¿yje przycisku potwierdzenia. Przed uruchomieniem wszystkich mechanizmów, u¿ytkownik mo¿e równie¿ podaæ adres zdalnego repozytorium Git lub œcie¿kê do sklonowanego repozytorium na dysku. 

\subsection{Analiza JDepend - tworzenie struktury programu}\label{r:jdepend}

Pierwszym krokiem analizy Shimmering Constellations jest uruchomienie analizatora JDepend na wskazanych plikach Ÿród³owych, b¹dŸ skompresowanych archiwach jar (analiza przez serwis JDepend mo¿e odbywaæ siê na obu rodzajach plików). Analizator JDepend bada klasy analizowanego projektu i wyniki swojego dzia³ania przedstawia w postaci posortowanej kolekcji danych dla poszczególnych pakietów. Obiekt przechowuj¹cy wyniki analizy dla konkretnego pakietu, posiada istotne cechy takie jak: nazwa pakietu, liczba klas konkretnych, liczba klas abstrakcyjnych, zbiór pakietów zale¿nych (afferent couplings oraz efferent couplings). 

Otrzymuj¹c taki zestaw danych, Shimmering Constellations przegl¹da ka¿dy z wyników i buduje strukturê analizowanego programu:

\begin{itemize}
\item Dodaje do grafu projektu wszystkie wierzcho³ki reprezentuj¹ce przeanalizowane pakiety oraz biblioteki, np. \texttt{shimmer.service.impl}.
\item Dla ka¿dego z wierzcho³ków, znajduje jego rodzica w drzewie pakietów i ³¹czy go za pomoc¹ krawêdzi pakietowej, np. \texttt{shimmer.service.imp} zostaje po³¹czone z rodzicem \texttt{shimmer.service}
	\begin{itemize}
	\item Jeœli rodzic nie jest korzeniem drzewa i nie znajduje siê w grafie, oznacza to, ¿e nale¿y dodaæ do grafu wierzcho³ek katalogowy i po³¹czyæ go krawêdzi¹ pakietow¹, np. rodzicem pakietu \texttt{shimmer.service} jest \texttt{shimmer}, ale taki pakiet nie wystêpuje w projekcie, dlatego zostaje dodany jako katalog. Ten proces odbywa siê rekurencyjnie do momentu zbudowania pe³nej œcie¿ki.
	\end{itemize}
\item Dla ka¿dego wierzcho³ka dodaje do grafu krawêdzie zale¿noœci na podstawie zbioru pakietów zale¿nych. Modyfikacja wprowadzona przeze mnie do biblioteki JDepend pozwala okreœliæ si³ê tych zale¿noœci.
\end{itemize}

\paragraph{Modyfikacja Afferent Couplings (Ca)} - Analizator JDepend podaje t¹ wartoœæ w sposób niestandardowy - w literaturze czêœciej spotykan¹ miar¹ jest liczba klas z obcych pakietów, które polegaj¹ na klasach z pakietu danego. Modyfikacja, któr¹ wprowadzi³em do analizatora JDepend pozwala na pozyskanie dodatkowej informacji - ile klas z wybranego pakietu polega na klasach z pakietu danego. Dziêki tej modyfikacji Shimmering Constellations zna nie tylko liczbê powi¹zañ z innymi pakietami, ale te¿ ich si³ê.

\paragraph{Modyfikacja Efferent Couplings (Ce)}-  Podobnie, jak w przypadku Afferent Couplings, wartoœæ liczona jest przez analizator JDepend przy uwzglêdnieniu si³y zale¿noœci - liczby klas zale¿nych. W tym obszarze równie¿ konieczna by³a modyfikacja kodu biblioteki.

\paragraph{} Po przeprowadzeniu tego kroku analizy, Shimmering Constellations posiada odwzorowanie badanego projektu w postaci grafu [dzia³ \ref{s:model-graph}] oraz zna podstawowe cechy jego wierzcho³ków (rozmiar, liczba klas abstrakcyjnych, pakiety zale¿ne itp.) i krawêdzi (si³a zale¿noœci, rodzaj powi¹zania). Dziêki tym informacjom Shimmering Constellations bêdzie w stanie przeprowadziæ wizualizacjê projektu w postaci grafu lub konstelacji.

\subsection{Analiza Findbugs - dodanie informacji o b³êdach}

Pierwsze próby u¿ycia biblioteki okaza³y siê bardzo niekorzystnie wp³ywaæ na czas wykonania g³ównej pêtli programu Shimmering Constellations i sk³oni³y mnie do szukania lepszego, bardziej wydajnego sposobu uruchamiania tego fragmentu analizy. Aby zwiêkszyæ wydajnoœæ narzêdzia, analiza wykonywana przez Findbugs uruchamiana jest w oddzielnym w¹tku, jako samodzielna instancja programu z odpowiednimi parametrami.

Parametry przekazywane analizatorowi Findbugs ró¿ni¹ siê w zale¿noœci od ustawieñ symulacji Shimmering Constellations:

\begin{itemize}
\item \texttt{effort:[min|max]} - ten parametr wy³¹cza analizy, które zwiêkszaj¹ precyzjê, ale zu¿ywaj¹ du¿e iloœci pamiêci - to ustawienie w trybie \texttt{min} pozwala przyspieszyæ dzia³anie programu kosztem iloœci wykrytych usterek
\item \texttt{relaxed} - raportowanie b³êdów nie opiera siê na sztywno zdefiniowanych heurystykach - gdy zale¿y nam na mniejszej iloœci detekcji false-positive, kosztem szybkoœci dzia³ania, Shimmering Constellations powinien zrezygnowaæ z tego parametru
\item \texttt{nested:false} - ustawienie zapobiega poszukiwaniu zagnie¿d¿onych archiwów zip i jar wewn¹trz wejœciowego katalogu projektu - ten parametr nie ulega zmianom
\item \texttt{xml} - tworzy plik wynikowy w postaci tekstu xml - ten parametr równie¿ pozostaje sta³y
\end{itemize}

Generowany przez Findbugs plik xml jest tworzony w katalogu tymczasowym, nastêpnie analizowany przez parser DOM. Report zawiera miêdzy innymi elementy reprezentuj¹ce wykryte usterki (element \texttt{BugInstance}). Shimmering Constellations parsuj¹c raport tworzy obiekty b³êdów i dodaje je do odpowiednich pakietów z grafu. Obiekt reprezentuj¹cy b³¹d posiada atrybuty nadane przez Findbugs, zgodne z przyjêtym modelem potencjalnej usterki [dzia³ \ref{s:model-bugs}]:

\begin{itemize}
\item \textbf{Nazwa klasy} - nazwa klasy, w której znaleziono potencjaln¹ usterkê - na jej podstawie Shimmering Constellations przypisuje usterki do pakietów
\item \textbf{Kategoria b³êdu} - etykieta kategoryzuj¹ca rozpoznan¹ usterkê np. \textit{Bad practice}
\item \textbf{Typ b³êdu} - identyfikator okreœlaj¹cy konkretny typ b³êdu rozpoznawanego przez Findbugs - na jego podstawie mo¿liwe jest pozyskanie dok³adniejszego opisu usterki w katalogu autorów Findbugs i naprawienie usterki
\item \textbf{Ranga b³êdu} - wartoœæ w przedziale 1-20 stwierdza poziom zagro¿enia usterki, gdzie 1 oznacza b³êdy najpowa¿niejsze, a 20 najdrobniejsze usterki
\item \textbf{Priorytet b³êdu} - ustalony przez Findbugs na podstawie rangi dla ³atwiejszego grupowania b³êdów: 
	\begin{itemize}
	\item scariest (ranga 1-4), 
	\item scary (ranga 5-9), 
	\item troubling (ranga 10-14), 
	\item of concern (ranga 15-20)
	\end{itemize}
\item \textbf{Pewnoœæ} - wartoœæ w przedziale 1-5 stwierdza stopieñ przekonania o poprawnoœci raportu, gdzie 1 oznacza b³¹d, którego pewnoœæ jest najmniejsza
\end{itemize}

Dodatkowe informacje, które Findbugs umieszcza w swoim raporcie, to statystyki pakietowe (elementy \texttt{PackageStats}). W obrêbie danego pakietu Findbugs podaje ³¹czn¹ liczbê potencjalnych usterek dla ka¿dego z 4 priorytetów b³êdów oraz listê statystyk klasowych (elementy \texttt{ClassStats}). Wa¿n¹ informacj¹ podan¹ dla ka¿dej klasy jest jej rozmiar - na jego podstawie Shimmering Constellations znajduje wartoœci metryk pakietowych, które opieraj¹ siê na rozmiarze klas - \textit{Total Size}, \textit{Largest Class Size} [dzia³ \ref{s:model-metrics}].

Aby policzyæ rozmiar danej klasy, Findbugs zlicza istotne konstrukcje wp³ywaj¹ce na jej rozmiar - pola, metody, linie instrukcji. Pomijane s¹ fragmenty, które nie wp³ywaj¹ na si³ê wyrazu, np. komentarze i bia³e znaki (NCSS - \textit{Non Commenting Source Statements}).

Informacje, które nie s¹ zawarte w pliku wynikowym raportu, to s³owna nazwa typu b³êdu i tekstowy opis usterki - jedyn¹ informacj¹ o typie b³êdu jest jego skrótowy identyfikator. Normaln¹ procedur¹ podczas korzystania z Findbugs jest u¿ywanie dostarczonego œrodowiska GUI, gdzie za³¹czone s¹ treœci opisów poszczególnych b³êdów, b¹dŸ pos³ugiwanie siê indeksem rozpoznawanych b³êdów, zamieszczonym na stronie projektu - wyszukuj¹c opisy wed³ug skrótowego identyfikatora. Aby poprawiæ jakoœæ i wygodê korzystania z Shimmering Constellations, przygotowa³em prosty parser aktualnego indeksu b³êdów i wczyta³em zawarte w nim dane do s³ownika. Dziêki temu znaj¹c identyfikator typu b³êdu, na etapie wizualizacji mo¿liwe jest wyœwietlenie pe³nego tekstowego raportu o b³êdach, ³¹cznie z tekstowymi opisami usterek.

Analiza Findbugs nie jest niezbêdnym krokiem wymaganym do wizualizacji projektu, dlatego ze wzglêdu na czasoch³onnoœæ tej czynnoœci mo¿liwe jest jej pominiêcie na ¿yczenie u¿ytkownika. Wyniki pozyskiwane w tym kroku pozwalaj¹ narzêdziu Shimmering Constellations wskazaæ najbardziej podejrzane pakiety i przedstawiæ czytelny raport usterek [dzia³ \ref{s:model-bugs}] dla ka¿dego z nich.

\subsection{Analiza JGit - dodanie informacji historycznych projektu}
Kolejnym krokiem analizy jest wydobycie metryk historycznych z repozytorium projektu. Warunkiem koniecznym do przeprowadzenia tego kroku jest posiadanie kopii reporytorium badanego projektu na dysku dostêpnym dla œrodowiska aplikacji Shimmering Constellations (JGit nie pozwala na ³atwe pozyskanie wymaganych informacji pos³uguj¹c siê jedynie zdalnym repozytorium). 
U¿ytkownik przed uruchomieniem analizy definiuje œcie¿kê dyskow¹ do repozytorium lokalnego. Jeœli u¿ytkownik nie posiada kopii repozytorium na swoim komputerze, mo¿liwe jest podanie adresu url repozytorium zdalnego, które zostanie automatycznie sklonowane do katalogu tymczasowego przez bibliotekê JGit. Ze wzglêdu na czasoch³onnoœæ klonowania, sugerowan¹ metod¹ jest przygotowanie repozytorium lokalnego przed analiz¹.

Maj¹c dostêp do repozytorium lokalnego, analizator przegl¹da wszystkie pliki podlegaj¹ce systemowi kontroli wersji i stara siê znaleŸæ w grafie projektu odpowiadaj¹ce im pakiety. Dopasowanie odbywa siê na zasadzie analizy œcie¿ki i nazwy pliku w repozytorium. Przyk³adowo plik znajduj¹cy siê pod œcie¿k¹: \verb+src\main\java\shimmer\service\GraphService.java+  zostanie dopasowany do pakietu \texttt{shimmer.service}. Jeœli dla danego pliku dopasowanie istnieje, narzêdzie JGit przegl¹da kontrybucje zmieniaj¹ce dany plik (liczba kontrybucji jest ograniczona do 500 wstecz) i dla danego pakietu w grafie aktualizuje liczbê wszystkich kontrybucji, datê ostatniej zmiany oraz liczbê autorów.

Analiza JGit nie jest obowi¹zkowym krokiem w procesie badania wybranego projektu, dlatego mo¿e zostaæ pominiêta na ¿yczenie u¿ytkownika. Informacje pozyskane w tym kroku wzbogacaj¹ wiedzê na temat historii zmian projektu i pozwalaj¹ na wygenerowanie mapy termicznej metryk historycznych w widoku konstelacji.

\subsection{Wyliczenie wartoœci metryk}
W tym kroku, na podstawie stworzonego grafu projektu, wyliczane s¹ wartoœci wszystkich metryk dostêpnych w programie, które wymagaj¹ dodatkowych kalkulacji. Niektóre metryki s¹ pozyskiwane bezpoœrednio w poprzednich krokach analizy i nie wymagaj¹ obliczeñ - szczegó³y przedstawiono w tabeli \ref{t:metrics-source}.

\begin{table}[t]
\centering
	\begin{tabular}{rl}
	\hline 
	Metryka & Sposób pozyskiwania \\
	\hline
	Class count & JDepend \\
	Concrete Classes & JDepend \\
	Abstract Classes & JDepend \\
	Total Size & Findbugs \\
	Largest Class Size & Findbugs \\
	Average Size & Wyliczona \\
	Afferent / Efferent Couplings & JDepend \\
	Abstractness & Wyliczona \\
	Instability & Wyliczona \\
	Abstract or Instable & Wyliczona \\
	Distance from the Main Sequence & Wyliczona \\
	Total Bugs & Findbugs \\
	Authors Count & JGit \\
	Last Commit & JGit \\
	Total Commits & JGit \\
	\hline
	\end{tabular} 
\caption{Podzia³ obs³ugiwanych metryk ze wzglêdu na Ÿród³o ich pozyskiwania}
\label{t:metrics-source}
\end{table}

\subsection{Serializacja}
Przeanalizowane dane serializowane s¹ do formatu JSON, który jest wymagany przez biblioteki wizualizacji grafów [dzia³ \ref{s:software-visualization}] - tablice wierzcho³ków i krawêdzi. 

Podczas serializacji wierzcho³ków i krawêdzi konieczne jest prze³o¿enie wartoœci metryk na odpowiednie atrybuty wizualizowanych obiektów. W zale¿noœci od ustawieñ u¿ytkownika oraz wartoœci wybranych metryk ustalane s¹:

\begin{itemize}
\item kolor wierzcho³ków
\item rozmiar wierzcho³ków
\item temperatura wierzcho³ków
\item d³ugoœæ krawêdzi
\end{itemize}

Zamiana wartoœci metryk na parametry wizualizacyjne odbywa siê oddzielnie dla ka¿dej metryki i parametru, a ustawienie odpowiednich proporcji zosta³o dobrane eksperymentalnie.

Na tym etapie brane pod uwagê s¹ równie¿ ustawienia kalibracyjne wizualizacji. Podczas pracy z projektami o ró¿nych parametrach u¿ytkownik mo¿e mieæ potrzebê przedefiniowania domyœlnych interpretacji wartoœci - przyk³adowo, jeœli nowy projekt posiada niewiele zmian w systemie kontroli wersji, chcemy aby wizualizacja mapy termicznej by³a bardziej wra¿liwa na liczbê zmian w danym pakiecie (pakiety z pozornie niewielk¹ iloœci¹ zmian powinny byæ uznawana za “gor¹ce”).

Obiekty powsta³e w wyniku serializacji (krawêdzie i wierzcho³ki w postaci JSON) stanowi¹ dane wejœciowymi dla narzêdzi wizualizacyjnych, ale zawieraj¹ równie¿ dodatkowe metadane, z których korzysta widok aplikacji Shimmering Constellations: informacje o wartoœciach wszystkich metryk, identyfikatory wykrytych usterek, kategorie wierzcho³ków.

\section{Realizacja wizualizacji}\label{s:software-visualization}
\subsection{Vis.js - graf}

Podstaw¹ do wizualizacji w Shimmering Constellation jest wizualizacja grafowa. Biblioteka, która odpowiada za wizualizowanie grafu to Vis.js \cite{b:visjs}. Narzêdzie pozwala na dynamiczn¹ wizualizacjê grafu w oparciu o model dystrybucji cz¹steczek Barnes-Hut.

VisJs pobiera wynik analizy w postaci list wierzcho³ków i krawêdzi w formacie JSON i wyœwietla graf projektu z odpowiednimi parametrami. Prezentowana wizualizacja jest równowa¿ona w czasie rzeczywistym i pozwala u¿ytkownikowi na dowolne manipulowanie grafem - skalowanie, przesuwanie, przemieszczanie wierzcho³ków.

\subsection{Heatmaps.js - mapa termiczna}

Dope³niaj¹cym elementem wizualizacji jest mapa termiczna, która wyœwietlana jest w tle wizualizowanego grafu. Generowaniem mapy termicznej zajmuje siê biblioteka heatmap.js \cite{b:heatmapsmapsjs}. Mapa termiczna oddaje temperaturê poszczególnych wierzcho³ków.

Ze wzglêdu na dynamiczny charakter prezentacji grafu, mapa termiczna jest odœwie¿ana z ustalon¹ czêstotliwoœci¹ za ka¿dym razem, gdy graf zmienia swoje po³o¿enie, jest równowa¿ony, lub skalowany. Dziêki temu mapa termiczna adaptuje zmiany, którym ulega graf i jest w stanie dostosowaæ siê do jego dynamicznego charakteru.

Ze wzglêdu na z³o¿onoœæ obliczeniow¹ odœwie¿ania mapy termicznej, u¿ytkownik mo¿e tymczasowo zatrzymaæ jej generowanie. Ta funkcjonalnoœæ mo¿e byæ przydatna przy pracy z du¿ymi projektami, kiedy u¿ytkownik chce zmodyfikowaæ u³o¿enie grafu - tymczasowe zatrzymanie mapy termicznej pozwoli na szybkie wykonanie zmian w grafie i uruchomienie mapy termicznej ju¿ po zrównowa¿eniu grafu, bez koniecznoœci oczekiwania na aktualizacjê mapy w ka¿dym kroku. 

\subsection{Sugerowane sposoby wizualizacji metryk}

Narzêdzie Shimmering Constellations pozwala u¿ytkownikowi na samodzielny wybór sposobu obrazowania poszczególnych metryk. Jenak niektóre z metryk, ze wzglêdu na swój charakter, w oczywisty sposób s¹ lepiej wyra¿ane za pomoc¹ konkretnych œrodków. Sugerowane sposoby wizualizacji metryk przedstawiono w tabeli \ref{t:metrics-visualization}

\begin{table}[t]
\centering
	\begin{tabular}{rl}
	\hline 
	Metryka & Sugerowany sposób obrazowania\\
	\hline
	Class count & rozmiar \\
	Concrete Classes & rozmiar \\
	Abstract Classes & rozmiar \\
	Total Size & rozmiar \\
	Largest Class Size & kolor \\
	Average Size & rozmiar lub kolor \\
	Afferent / Efferent Couplings & d³ugoœæ krawêdzi \\
	Abstractness & kolor lub temperatura \\
	Instability & kolor lub temperatura \\
	Abstract or Instable & kolor \\
	Distance from the Main Sequence & kolor \\
	Total Bugs & kolor \\
	Authors Count & temperatura \\
	Last Commit & temperatura \\
	Total Commits & temperatura \\
	\hline
	\end{tabular} 
\caption{Zestawienie sugerowanych sposobów wizualizacji poszczególnych metryk}
\label{t:metrics-visualization}
\end{table}

\section{Funkcjonalnoœæ}

Ten dzia³ przedstawia zestawienie kluczowych funkcjonalnoœci dostarczanych przez stworzone oprogramowanie.

\subsection{Dwie metody wizualizacji}

Shimmering Constellations udostêpnia dwie metody wizualizacji projektów: graf oraz konstelacja.

Wizualizacja grafowa jest podstawow¹ metod¹ pozwalaj¹c¹ w jawny sposób przedstawiæ powi¹zania pomiêdzy pakietami lub kompletne drzewo zagnie¿d¿enia pakietów. Przyjêty model grafu projektu jest w sposób bezpoœredni odwzorowywany w wizualizacji.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img1.png}
\caption{Projekt jUnit wizualizowany w postaci grafu}
\end{figure}

Wizualizacja konstelacyjna opiera siê na za³o¿eniach przestawionych w pracy \cite{b:constellation}. Podstaw¹ do jej stworzenia jest graf projektu, jednak krawêdzie s¹ niewidoczne, a zale¿noœci miêdzy pakietami s¹ obrazowane przez odleg³oœci miêdzy wierzcho³kami. W tym widoku szczególne zastosowanie odnajduje mapa termiczna, która wzbogaca si³ê jego wyrazu o dodatkowy parametr - temperaturê wierzcho³ków.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img2.png}
\caption{Projekt jUnit wizualizowany w postaci konstelacji}
\end{figure}

Metodê wizualizacji mo¿na zmieniæ w trakcie dzia³ania programu, bez koniecznoœci analizowania projektu na nowo.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{img3.png}
\caption{Panel zmiany metody wizualizacji}
\end{figure}

\subsection{Czytelny raport usterek}

Po wybraniu pakietu, Shimmering Constelations wyœwietla czytelny raport usterek wykrytych przez analizator Findbugs. Szczegó³owe opisy usterek pochodz¹ z oficjalnej dokumentacji Findbugs.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img4.png}
\caption{Fragment raportu usterek dla pakietu org.junit.rules z projektu JUnit}
\end{figure}

\subsection{Dynamicznie modyfikowane parametry analizy}

Shimmering Constelations pozwala u¿ytkownikowi decydowaæ o tym, jakie metryki powinny byæ wizualizowane za pomoc¹ ka¿dego z dostêpnych parametrów (d³ugoœæ krawêdzi, kolor, rozmiar i temperatura wierzcho³ków). Ponadto pozwala na wykluczenie szczególnych typów wierzcho³ków i krawêdzi z wizualizacji - przyk³adowo u¿ytkownik mo¿e zdecydowaæ o ukryciu pakietów bibliotecznych, a zdecydowaæ siê na wyœwietlenie wierzcho³ków symbolizuj¹cych katalogi pakietów.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img5.png}
\caption{Panel ustawieñ symulacji}
\end{figure}

Odpowiednio dobrane ustawienia mog¹ zale¿eæ od celu u¿ytkownika - widok grafowy z krawêdziami drzewa pakietów i wierzcho³kami katalogowymi mo¿e w œcis³y sposób oddaæ fizyczn¹ architekturê projektu. Natomiast widok konstelacyjny bez pakietów bibliotecznych i katalogów, z krawêdziami zale¿noœci o wa¿onych d³ugoœciach pozwoli skupiæ siê na jakoœci kodu zawartego w projekcie.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{img6.png}
\caption{Wybór metryki dla temperatury wierzcho³ka}
\end{figure}

Manipulacja ustawieniami odbywa siê w sposób dynamiczny, a wprowadzanie zmian do wizualizacji nie wymaga ponownej analizy projektu.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img7.png}
\caption{Krawêdzi oznaczaj¹ zale¿noœci eferentne pakietów, a ich d³ugoœæ wskazuje na si³ê zale¿noœci - liczbê klas zale¿nych. Wielkoœæ wierzcho³ków oznacza liczbê klas w pakiecie, a kolor liczbê wykrytych usterek.}
\end{figure}

\subsection{Kalibracja metryk i wizualizacji}

Przy pracy z projektami o ró¿nych charakterystykach konieczne mo¿e byæ naniesienie pewnych poprawek interpretacyjnych na mechanizm obrazowania metryk. Przyk³adowo w projekcie uruchamianym jedynie testowo / lokalnie, mo¿emy zdecydowaæ siê na tolerowanie kilku usterek zg³oszonych przez Findbugs - wtedy u¿ytkownik mo¿e zwiêkszyæ próg tolerancji liczby b³êdów, tak aby kolor wierzcho³ków (jeœli u¿ywamy go do obrazowania liczby b³êdów) nie by³ zbyt jednolity. Dla przeciwnego przyk³adu - w projekcie, który powinien cechowaæ siê du¿¹ niezawodnoœci¹, u¿ytkownik mo¿e zmniejszyæ próg tolerancji b³êdów, aby oznaczyæ wszystkie podejrzane wierzcho³ki z wiêksz¹ dok³adnoœci¹.

Podobnym ustawieniom mo¿e podlegaæ jeszcze szereg parametrów kalibracyjnych:

\begin{itemize}
\item rozmiar wierzcho³ka
\item wiek zmian
\item liczba zmian w systemie kontroli wersji
\item liczba klas w pakiecie
\item rozmiar klasy
\end{itemize}

Zmiany tych parametrów nie wymagaj¹ ponownej analizy.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img8.png}
\caption{Panel kalibracji metryk}
\end{figure}

Dynamicznym modyfikacjom mog¹ podlegaæ równie¿ ustawienia aparatu fizycznego symulacji. Odpowiednie ustawienie takich parametrów, jak sta³a grawitacyjna lub domyœlna d³ugoœæ krawêdzi (w u¿ywanym modelu fizycznym reprezentowanych jako sprê¿yny) mo¿e byæ ró¿ne dla projektów o odmiennych parametrach i nieznacznie odbiegaæ od ustawieñ domyœlnych. Zaawansowany u¿ytkownik bêdzie w stanie w pe³ni kontrolowaæ symulacjê fizyczn¹ wedle potrzeb zmieniaj¹c jej charakter na bardziej dynamiczny, statyczny, rozleg³y, skupiony itp.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img9.png}
\caption{Panel ustawieñ modelu fizycznego}
\end{figure}

\subsection{Mo¿liwoœæ zapisu i odczytu wyników analizy}

Czasoch³onnoœæ procesu analizy sk³oni³a mnie do umo¿liwienia u¿ytkownikowi zapisania wyników na dysku i odtworzenia wizualizacji bez koniecznoœci wykonywania obliczeñ. W pliku tekstowym, oprócz elementów grafu w postaci JSON zapisywane s¹ równie¿ ustawienia symulacji.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{img10.png}
\caption{Panel zapisu  / odczytu gotowego projektu}
\end{figure}

\subsection{Przystêpny interfejs u¿ytkownika}

Interfejs aplikacji zosta³ stworzony z myœl¹ o intuicyjnoœci i wygodzie u¿ytkownika. Do komunikacji z u¿ytkownikiem wykorzystano dynamiczne komponenty oparte o biblioteki Bootstrap i PrimeFaces. Ponadto zadbano o wszelkie udogodnienia wp³ywaj¹ce na jakoœæ interfejsu - pasek postêpu obliczeñ, animacje komponentów, wskaŸnik równowa¿enia grafu, gradacjê kolorystyczn¹ w odwzorowaniu wartoœci metryk.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img11.png}
\caption{Ekran g³ówny programu Shimmering Constelletions}
\end{figure}

\subsection{Mo¿liwoœæ przeprowadzenia analizy czêœciowej}

Aby skróciæ czas oczekiwania na wyniki obliczeñ, u¿ytkownik mo¿e zdecydowaæ o pominiêciu niektórych etapów analizy. Analiza Findbugs (poszukiwanie usterek) oraz JGit (wydobywanie metryk historycznych z repozytorium) nie s¹ niezbêdne do przeprowadzenia wizualizacji - w rezultacie niektóre wyniki obliczeñ nie bêd¹ dostêpne przy symulacji. Ta funkcjonalnoœæ jest przydatna, jeœli znany jest konkretny cel wizualizacji i wiemy, jakich informacji o projekcie nie chcemy obrazowaæ - mo¿emy wtedy zrezygnowaæ z czasoch³onnych obliczeñ.  Ponadto u¿ytkownik mo¿e zmniejszyæ priorytet analizatora Findbugs - poskutkuje to szybszym dzia³aniem, ale zg³oszeniem wiêkszej iloœci b³êdów false-positive.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img12.png}
\caption{Panel umo¿liwiaj¹cy pominiêcie wybranych modu³ów}
\end{figure}

% ------------------------------------------------------------------------------
% ROZDZIA£ BADANIA
% ------------------------------------------------------------------------------
\chapter{Badanie, wyniki oraz wnioski}\label{c:research}
Aby wykazaæ dzia³anie stworzonego oprogramowania, rozs¹dnym krokiem jest prezentacja jego przyk³adowego u¿ycia, lub zebranie opinii u¿ytkowników.

W tym rozdziale przedstawiono przyk³adowe zastosowanie programu Shimmering Constellations do analizy popularnych projektów. Ponadto, w celu weryfikacji nowych metod wizualizacyjnych przeprowadzono ankietê wœród studentów kierunku Informatyka. Ostatecznie zebrano wnioski p³yn¹ce z przyk³adów wizualizacji i przeprowadzonego badania.

\section{Przyk³ady wizualizacji}

%TODO
\paragraph{TODO:}
\textit{Umieszczê 3 przyk³adowe wizualizacje znanych projektów z krótkimi opisami}

\section{Ankieta}

Aby poznaæ opiniê u¿ytkowników na temat konstelacyjnej metody wizualizacji i porównaæ j¹ z popularn¹ wizualizacj¹ grafow¹, przeprowadzono ankietê wœród studentów Uniwersytetu Warszawskiego. W badaniu wziê³a udzia³ grupa 100 uczestników kursu In¿ynieria Oprogramowania, której zaprezentowano oprogramowanie Shimmering Constelations. W konfiguracji testowej, oprogramowanie umo¿liwia³o wyœwietlenie projektu jUnit za pomoc¹ grafu oraz konstelacji. Nastêpnie, po obejrzeniu obu wizualizacji, uczestnicy udzielali odpowiedzi na nastêpuj¹ce pytania:

\begin{enumerate}
\item Któr¹ metodê wizualizacji preferujesz?
\item Która metoda wizualizacji wydaje Ci siê czytelniejsza?
\item Która metoda wizualizacji wydaje Ci siê bardziej estetyczna?
\item Która metoda pozwala szybciej wykryæ podejrzane elementy projektu?
\item Która z metod lepiej demonstruje architekturê projektu?
\item Bêd¹c na pozycji osoby decyzyjnej (np. Project Director decyduj¹cy o finansowaniu projekt), której metody wola³byœ u¿ywaæ do szybkiej oceny sytuacji w projekcie?
\item Bêd¹c na miejscu in¿yniera pracuj¹cego nad projektem (np. cz³onek zespo³u programistów, który refaktoryzuje kod), któr¹ z metod wybra³byœ do codziennej pracy?
\end{enumerate}

 Dobór pytañ testowych mia³ w zamyœle wykrycie wyraŸnych ró¿nic w charakterze i zastosowaniach metody konstelacyjnej i klasycznej grafowej.

%TODO
\paragraph{TODO:}
\textit{Umieszczê wyniki ankiety w tabeli lub na wykresie}

\section{Wnioski}

%TODO
\paragraph{TODO:}
\textit{Krótko podsumujê wnioski wyci¹gniête z ankiety}

% ------------------------------------------------------------------------------
% ROZDZIA£ PODSUOWANIE
% ------------------------------------------------------------------------------
\chapter{Podsumowanie pracy}\label{c:summary}

W pracy opisano narzêdzie do wizualizacji projektów informatycznych, którego kod udostêpniono na zasadach Open Source. Program Shimmering Constelletion ³¹czy w sobie techniki wizualizacji konstelacyjnej oraz grafowej ze zintegrowan¹ map¹ termiczn¹. Wizualizacja kodu w programie pozwala nie tylko w sposób czytelny zobrazowaæ dany projekt, ale uwzglêdnia te¿ zachodz¹ce w nim zmiany i umo¿liwia analizê jakoœci. Skutecznoœæ wykorzystanych metod w poszczególnych obszarach zastosowañ potwierdzi³y przeprowadzone badania preferencji u¿ytkowników.

\section{Perspektywy dalszego rozwoju oprogramowania}\label{s:summary-future}

Oprogramowanie Shimmering Constellations powsta³o z myœl¹ o mo¿liwoœci przysz³ego rozbudowywania jego funkcjonalnoœci. Architektura i implementacja [patrz rozdzia³ \ref{r:architektura} oraz \ref{s:software-implementation}] aplikacji by³y tworzone zgodnie ze sztuk¹ pragmatycznego programowania, aby umo¿liwiæ dalszy rozwój systemu i zapewniæ jego wysok¹ skalowalnoœæ. Obecnie przewidziano nastêpuj¹ce mo¿liwoœci rozwoju narzêdzia:

\paragraph{Zwiêkszenie granularnoœci:} Korzystnym krokiem w rozwoju systemu by³oby zwiêkszenie granularnoœci wizualizacji. Obecnie kod obrazowany przez Shimmering Constellations przedstawiany jest na poziomie pakietów i na tym stopniu liczona jest wiêkszoœæ dostarczanych metryk. Rozbudowanie aplikacji o analizê na poziomie poszczególnych klas wymaga³oby jedynie niewielkich zmian w analizatorze JDepend [rozdzia³ \ref{r:jdepend}] i modelu projektu [rozdzia³ \ref{c:model}]. Biblioteka wizualizacyjna visJs pozwala na automatyczn¹ obs³ugê klastrowania wierzcho³ków - dziêki temu wierzcho³ki reprezentuj¹ce klasy mog³yby ³¹czyæ siê w wierzcho³ki klastrowe reprezentuj¹ce poszczególne pakiety (stan obecny). Takie rozbudowanie zwiêkszy³oby dok³adnoœæ narzêdzie Shimmering Constellations.

\paragraph{Uruchomienie aplikacji www:} Dobrym wykorzystaniem narzêdzia Shimmering Constellations mog³oby by byæ uruchomienie go w postaci us³ugi online na serwerach uczelni w celach naukowych. Uczestnicy kursu In¿ynieria Oprogramowania mogliby przy u¿yciu opisanego programu analizowaæ wybrane projekty informatyczne, a wyniki analiz zbierane w bazie danych pozwoli³yby badaæ studentom i pracownikom instytutu projekty Open Source. Taka modyfikacja, dziêki architekturze opartej na aplikacji www [patrz rozdzia³ \ref{r:architektura}], wymaga³aby jedynie integracji z wybran¹ baz¹ danych. 

\paragraph{Dodanie nowych metryk i modu³ów:} Oczywistym rozszerzeniem dla aplikacji Shimmering Constellations jest implementacja nowych metryk i modu³ów analizuj¹cych kod projektu. Chc¹c wzbogaciæ program o mo¿liwoœæ wizualizacji dodatkowej metryki, nale¿y dodaæ odpowiedni analizator do g³ównego procesu programu [rozdzia³ \ref{s:software-analysis}], rozbudowaæ model o nowe w³aœciwoœci [rozdzia³ \ref{c:model}] i zadbaæ o odpowiednie obrazowanie nowej cechy [rozdzia³ \ref{s:software-visualization}].


% ------------------------------------------------------------------------------
% DODATEK
% ------------------------------------------------------------------------------

\appendix

\chapter{Co nale¿y jeszcze zrobiæ w pracy}
\begin{itemize}
\item Uzupe³niæ brakuj¹ce fragmenty (TODO) - niektóre brakuj¹ce sekcje i cytowania.
\item Ustaliæ w jaki sposób odnieœæ siê do opisu niektórych bibliotek. Przyk³adowo, jeœli VisJs nie posiada ¿adnej publikacji naukowej, to czy powinien znaleŸæ siê w bibliografii? Mo¿e dobrym krokiem jest podanie adresu URL do dokumentacji biblioteki? Czy taki adres bêdzie w bibliografii?
\item Ujednoliciæ sposób nazywania niektórych rzeczy. Przyk³adowo': vis.js, VisJS, visJs
\item Ustaliæ sposób nazywania niektórych wyrazów z jêzyka angielskiego lub jakoœ sformatowaæ te wyst¹pienia. Przyk³adowo: framework, nazwy metryk.
\item Poprawiæ formatowanie tekstu w rozdziale o przebiegu analizy - u¿yæ funkcji pogrubienia tekstu i kursywy dla niektórych elementów.
\item Ustaliæ prawid³ow¹ klasyfikacjê tematyczn¹ pracy.
\item Przemyœleæ lepsze s³owa kluczowe.
\item Zmieniæ tytu³ / abstrakt tak, aby bardziej podkreœla³ rolê stworzonego oprogramowania w mojej pracy?
\item Usun¹æ ten dodatek.
\end{itemize}

\chapter{Oprogramowanie Shimmering Constellations}

Oprogramowanie opisane w pracy znajduje siê na za³¹czonej p³ycie CD oraz pod adresem: \url{http://students.mimuw.edu.pl/~fd305199/shimmer/shimmer.zip}

Za³¹czona paczka zawiera kod programu Shimmering Constellations napisany w jêzyku Java. W katalogu \verb+src\+ znajduje siê kod klas programu. W katalogu \verb+etc\thesis+ umieszczono kod Ÿród³owy tego dokumentu. Plik \verb+pom.xml+ zawiera zewstaw konfiguracji dla narzêdzie Maven, które mo¿e skompilowaæ program Shimmering Constellations. Skompilowany program znajdzie siê w katalogu \verb+target\+ i mo¿e zostaæ uruchomiony w œrodowisku uruchomieniowym Jboss 7.1.1.

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem{b:vissoft} \url{http://vissoft.dcc.uchile.cl/}

\bibitem{b:graph} Erdemir, U.; Tekin, U.; Buzluca, F., \textit{E-Quality: A graph based object oriented software quality visualization tool} Visualizing Software for Understanding and Analysis (VISSOFT), 2011 6th IEEE International Workshop on , vol., no., pp.1,8, 29-30 Sept. 2011

\bibitem{b:constellation} Fang Deng; DiGiuseppe, N.; Jones, J.A., \textit{Constellation visualization: Augmenting program dependence with dynamic information}, Visualizing Software for Understanding and Analysis (VISSOFT), 2011 6th IEEE International Workshop on , vol., no., pp.1,8, 29-30 Sept. 2011

\bibitem{b:tarantulla} J. A. Jones, M. J. Harrold, and J. Stasko., \textit{Visualization of test information to assist fault localization}, Proceedings of the International
Conference on Software Engineering, ICSE ’02, pages 467–477, New York, NY, USA, 2002. ACM.

\bibitem{b:heatmaps} Benomar, O.; Sahraoui, H.; Poulin, P., \textit{Visualizing software dynamicities with heat maps}, Software Visualization (VISSOFT), 2013 First IEEE Working Conference on , vol., no., pp.1,10, 27-28 Sept. 2013

\bibitem{b:metrics} Martin, Robert C. \textit{Design principles and design patterns}, Object Mentor, 2000: 1-34. 

\bibitem{b:historical-metrics} Mahmoud O. Elish; Mojeeb Al-Rahman Al-Khiaty \textit{A suite of metrics for quantifying historical changes to predict future change-prone classes in object-oriented software}, Journal of Software: Evolution and Process, Volume 25, Issue 5, pages 407–437, May 2013

\bibitem{b:jdepend} Mike Clark \textit{JDepend}, 1999-2009 Clarkware Consulting, Inc. \url{http://clarkware.com/software/JDepend.html}

\bibitem{b:findbugs} David Hovemeyer; William Pugh. 2004. \textit{Finding bugs is easy}, SIGPLAN Not. 39, 12 (December 2004), 92-106

\bibitem{b:jgit} \textit{JGit}, The Eclipse Foundation, 2015 \url{http://www.eclipse.org/jgit/}

\bibitem{b:visjs} J. Jong; A. Mulder, \textit{Vis.js}, Almende B.V. 2010 - 2015, \url{http://visjs.org/} 

\bibitem{b:heatmapsmapsjs} P. Wied, \textit{heatmap.js}, 2014 - 2015, \url{http://www.patrick-wied.at/static/heatmapjs/}

\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
